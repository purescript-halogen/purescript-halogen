<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Halogen Guide</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Halogen</a></li><li class="chapter-item expanded "><a href="guide/index.html"><strong aria-hidden="true">2.</strong> Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guide/01-Rendering-Halogen-HTML.html"><strong aria-hidden="true">2.1.</strong> Rendering Halogen HTML</a></li><li class="chapter-item expanded "><a href="guide/02-Introducing-Components.html"><strong aria-hidden="true">2.2.</strong> Introducing Components</a></li><li class="chapter-item expanded "><a href="guide/03-Performing-Effects.html"><strong aria-hidden="true">2.3.</strong> Performing Effects</a></li><li class="chapter-item expanded "><a href="guide/04-Lifecycles-Subscriptions.html"><strong aria-hidden="true">2.4.</strong> Lifecycles &amp; Subscriptions</a></li><li class="chapter-item expanded "><a href="guide/05-Parent-Child-Components.html"><strong aria-hidden="true">2.5.</strong> Parent &amp; Child Components</a></li><li class="chapter-item expanded "><a href="guide/06-Running-Application.html"><strong aria-hidden="true">2.6.</strong> Running Application</a></li><li class="chapter-item expanded "><a href="guide/07-Next-Steps.html"><strong aria-hidden="true">2.7.</strong> Next Steps</a></li></ol></li><li class="chapter-item expanded "><a href="concepts-reference/index.html"><strong aria-hidden="true">3.</strong> Concepts Reference</a></li><li class="chapter-item expanded "><a href="changelog/index.html"><strong aria-hidden="true">4.</strong> Major Version Changelog</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="changelog/v6.html"><strong aria-hidden="true">4.1.</strong> Changes in v6</a></li><li class="chapter-item expanded "><a href="changelog/v5.html"><strong aria-hidden="true">4.2.</strong> Changes in v5</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Halogen Guide</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/purescript-halogen/purescript-halogen" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#halogen-documentation" id="halogen-documentation">Halogen Documentation</a></h1>
<p>Halogen is a declarative, type-safe library for building user interfaces.</p>
<p>This documentation covers how to use Halogen and provides a concepts reference. There are also other resources for learning and using Halogen, including:</p>
<ul>
<li>The Halogen <a href="https://pursuit.purescript.org/packages/purescript-halogen">API Reference</a></li>
<li><a href="https://github.com/thomashoneyman/purescript-halogen-realworld">Real World Halogen</a> by <a href="https://github.com/thomashoneyman">Thomas Honeyman</a></li>
<li><a href="https://github.com/JordanMartinez/learn-halogen">Learn Halogen</a> by <a href="https://github.com/JordanMartinez">Jordan Martinez</a></li>
</ul>
<h2><a class="header" href="#quick-start-halogen-guide" id="quick-start-halogen-guide">Quick Start: Halogen Guide</a></h2>
<p>If you are new to Halogen we recommend starting with the <a href="./guide">Halogen Guide</a>. This short handbook demonstrates and explains Halogen concepts while building components.</p>
<p>By the end of the guide you'll be ready to dive in to more advanced resources like the <a href="./concepts-reference">Concepts Reference</a> or <a href="https://github.com/thomashoneyman/purescript-halogen-realworld">Real World Halogen</a>.</p>
<h2><a class="header" href="#going-deeper-concepts-reference" id="going-deeper-concepts-reference">Going Deeper: Concepts Reference</a></h2>
<p>Once you're comfortable with the main concepts from the <a href="./guide">Halogen Guide</a> you may be interested in more advanced topics and in understanding why Halogen features are designed the way they are. The <a href="./concepts-reference">Concepts Reference</a> will help you understand Halogen at a deeper level.</p>
<h2><a class="header" href="#major-version-changelog" id="major-version-changelog">Major Version Changelog</a></h2>
<p>Major Halogen releases are accompanied by guides for transitioning from one version to the next in the <a href="./changelog">Major Version Changelog</a>. Currently, there are transition guides for the following versions:</p>
<ul>
<li><a href="./changelog/v6.html">v6</a></li>
<li><a href="./changelog/v5.html">v5</a></li>
</ul>
<h1><a class="header" href="#halogen-guide" id="halogen-guide">Halogen Guide</a></h1>
<p>Halogen is a declarative, component-based UI library for PureScript that emphasizes type safety. In this guide you will learn the core ideas and patterns needed to write real-world applications in Halogen.</p>
<p>Here is a tiny Halogen app that lets you increment and decrement a counter:</p>
<pre><code class="language-purs">module Main where

import Prelude

import Effect (Effect)
import Halogen as H
import Halogen.Aff as HA
import Halogen.HTML as HH
import Halogen.HTML.Events as HE
import Halogen.VDom.Driver (runUI)

main :: Effect Unit
main = HA.runHalogenAff do
  body &lt;- HA.awaitBody
  runUI component unit body

data Action = Increment | Decrement

component =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval $ H.defaultEval { handleAction = handleAction }
    }
  where
  initialState _ = 0

  render state =
    HH.div_
      [ HH.button [ HE.onClick \_ -&gt; Decrement ] [ HH.text &quot;-&quot; ]
      , HH.div_ [ HH.text $ show state ]
      , HH.button [ HE.onClick \_ -&gt; Increment ] [ HH.text &quot;+&quot; ]
      ]

  handleAction = case _ of
    Increment -&gt; H.modify_ \state -&gt; state + 1
    Decrement -&gt; H.modify_ \state -&gt; state - 1
</code></pre>
<p>You can paste this example (and any other full examples in this guide) into <a href="https://try.purescript.org">Try PureScript</a>. We highly recommend doing this to explore the examples interactively! For example, try changing the buttons so they use the words <code>&quot;Increment&quot;</code> and <code>&quot;Decrement&quot;</code> instead of the symbols <code>&quot;+&quot;</code> and <code>&quot;-&quot;</code>.</p>
<blockquote>
<p>By default, Try PureScript will compile every time you make a change. You can also disable the auto-compile feature, which will cause Try PureScript to wait for you to click the &quot;Compile&quot; button to compile your Halogen application.</p>
</blockquote>
<p>You can also create your own starter project with the <a href="https://github.com/purescript-halogen/purescript-halogen-template">official Halogen template</a>. This template includes extra tools and scripts to help you get up and running with a full Halogen application.</p>
<p>Don't worry if this code is overwhelming at first -- when you've read the next few chapters of the guide you'll gain a solid understanding of how this component works and how to write your own.</p>
<h2><a class="header" href="#how-to-read-this-guide" id="how-to-read-this-guide">How to Read This Guide</a></h2>
<p>In this guide we'll explore the building blocks of Halogen apps: elements and components. When you understand these you can create complex apps from small, reusable pieces.</p>
<p>This is a step-by-step introduction to Halogen's main concepts. Each chapter builds on knowledge introduced in previous chapters, so we recommend reading through the guide in order.</p>
<p>Halogen is a PureScript library, and it assumes basic knowledge of PureScript concepts like functions, records, arrays, <code>do</code> notation, <code>Effect</code>, and <code>Aff</code>. It will also help if you understand the basics of HTML and the DOM. If you need a refresher, we recommend:</p>
<ul>
<li>For PureScript: the <a href="https://book.purescript.org">PureScript Book</a> and Jordan Martinez's <a href="https://github.com/JordanMartinez/purescript-jordans-reference">PureScript Reference</a>.</li>
<li>For HTML: the MDN introductions to <a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML">HTML</a> and <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events">DOM events</a>.</li>
</ul>
<h2><a class="header" href="#table-of-contents" id="table-of-contents">Table of Contents</a></h2>
<ol>
<li><a href="guide/./01-Rendering-Halogen-HTML.html">Rendering Halogen HTML</a></li>
<li><a href="guide/./02-Introducing-Components.html">Introducing Components</a></li>
<li><a href="guide/./03-Performing-Effects.html">Performing Effects</a></li>
<li><a href="guide/./04-Lifecycles-Subscriptions.html">Lifecycles &amp; Subscriptions</a></li>
<li><a href="guide/./05-Parent-Child-Components.html">Parent &amp; Child Components</a></li>
<li><a href="guide/./06-Running-Application.html">Running An Application</a></li>
<li><a href="guide/./07-Next-Steps.html">Next Steps</a></li>
</ol>
<h1><a class="header" href="#rendering-halogen-html" id="rendering-halogen-html">Rendering Halogen HTML</a></h1>
<p>Halogen HTML elements are the smallest building block of Halogen applications. These elements describe what you want to see on the screen.</p>
<p>Halogen HTML elements are not components (we'll get to components in the next chapter), and they can't be rendered without a component. However, it's common to write helper functions that produce Halogen HTML and then use those functions in a component.</p>
<p>We'll explore writing HTML without components or events in this chapter.</p>
<h2><a class="header" href="#halogen-html" id="halogen-html">Halogen HTML</a></h2>
<p>You can write Halogen HTML using functions from the <code>Halogen.HTML</code> or <code>Halogen.HTML.Keyed</code> modules as in this example:</p>
<pre><code class="language-purs">import Halogen.HTML as HH

element = HH.h1 [ ] [ HH.text &quot;Hello, world&quot; ]
</code></pre>
<p>Halogen HTML elements can be thought of like browser DOM elements, but they are controlled by the Halogen library instead of being actual elements in the DOM. Under the hood, Halogen takes care of updating the actual DOM to match the code you have written.</p>
<p>Elements in Halogen accept two arguments:</p>
<ol>
<li>An array of attributes, properties, event handlers, and/or references to apply to the element. These correspond with ordinary HTML properties like <code>placeholder</code> and event handlers like <code>onClick</code>. We'll learn how to handle events in the next chapter, and we'll only focus on properties in this chapter.</li>
<li>An array of children, if the element supports children.</li>
</ol>
<p>As a brief example, let's translate this ordinary HTML into Halogen HTML:</p>
<pre><code class="language-html">&lt;div id=&quot;root&quot;&gt;
  &lt;input placeholder=&quot;Name&quot; /&gt;
  &lt;button class=&quot;btn-primary&quot; type=&quot;submit&quot;&gt;
    Submit
  &lt;/button&gt;
&lt;/div&gt;
</code></pre>
<p>Let's break down our Halogen HTML:</p>
<ol>
<li>Our Halogen code has the same shape as our ordinary HTML: a <code>div</code> containing an <code>input</code> and a <code>button</code>, which itself contains plain text.</li>
<li>Properties move from key-value pairs inside the tags into an array of properties for the element.</li>
<li>Child elements move from being inside an open and closing tag into an array of children, if the element supports children.</li>
</ol>
<p>Functions for writing properties in your HTML come from the <code>Halogen.HTML.Properties</code> module.</p>
<pre><code class="language-purs">import Halogen.HTML as HH
import Halogen.HTML.Properties as HP

html =
  HH.div
    [ HP.id &quot;root&quot; ]
    [ HH.input
        [ HP.placeholder &quot;Name&quot; ]
    , HH.button
        [ HP.classes [ HH.ClassName &quot;btn-primary&quot; ]
        , HP.type_ HP.ButtonSubmit
        ]
        [ HH.text &quot;Submit&quot; ]
    ]
</code></pre>
<p>You can see Halogen's emphasis on type safety displayed here.</p>
<ol>
<li>A text input can't have children, so Halogen doesn't allow the element to take further elements as an argument.</li>
<li>Only some values are possible for a button's <code>type</code> property, so Halogen restricts them with a sum type.</li>
<li>CSS classes use a <code>ClassName</code> newtype so that they can be treated specially when needed; for example, the <code>classes</code> function ensures that your classes are space-separated when they're combined.</li>
</ol>
<p>Some HTML elements and properties clash with reserved keywords in PureScript or with common functions from the Prelude, so Halogen adds an underscore to them. That's why you see <code>type_</code> instead of <code>type</code> in the example above.</p>
<p>When you don't need to set any properties on a Halogen HTML element, you can use its underscored version instead. For example, the <code>div</code> and <code>button</code> elements below have no properties:</p>
<pre><code class="language-purs">html = HH.div [ ] [ HH.button [ ] [ HH.text &quot;Click me!&quot;] ]
</code></pre>
<p>That means we can rewrite them using their underscored versions. This can help keep your HTML tidy.</p>
<pre><code class="language-purs">html = HH.div_ [ HH.button_ [ HH.text &quot;Click me!&quot; ] ]
</code></pre>
<h2><a class="header" href="#writing-functions-in-halogen-html" id="writing-functions-in-halogen-html">Writing Functions in Halogen HTML</a></h2>
<p>It's common to write helper functions for Halogen HTML. Since Halogen HTML is built from ordinary PureScript functions, you can freely intersperse other functions in your code. </p>
<p>In this example, our function accepts an integer and renders it as text:</p>
<pre><code class="language-purs">header :: forall w i. Int -&gt; HH.HTML w i
header visits = 
  HH.h1_ 
    [ HH.text $ &quot;You've had &quot; &lt;&gt; show visits &lt;&gt; &quot; visitors&quot; ] 
</code></pre>
<p>We can also render lists of things:</p>
<pre><code class="language-purs">lakes = [ &quot;Lake Norman&quot;, &quot;Lake Wylie&quot; ]

html :: forall w i. HH.HTML w i
html = HH.div_ (map HH.text lakes)
-- same as: HH.div_ [ HH.text &quot;Lake Norman&quot;, HH.text &quot;Lake Wylie&quot; ]
</code></pre>
<p>These function introduced a new type, <code>HH.HTML</code>, which you haven't seen before. Don't worry! This is the type of Halogen HTML, and we'll learn about it in the next section. For now, let's continue learning about using functions in HTML.</p>
<p>One common requirement is to conditionally render some HTML. You can do this with ordinary <code>if</code> and <code>case</code> statements, but it's useful to write helper functions for common patterns. Let's walk through two helper functions you might write in your own applications, which will help us get more practice writing functions with Halogen HTML.</p>
<p>First, you may sometimes need to deal with elements that may or may not exist. A function like the one below lets you render a value if it exists, and render an empty node otherwise.</p>
<pre><code class="language-purs">maybeElem :: forall w i a. Maybe a -&gt; (a -&gt; HH.HTML w i) -&gt; HH.HTML w i
maybeElem val f =
  case val of
    Just x -&gt; f x
    _ -&gt; HH.text &quot;&quot;

-- Render the name, if there is one
renderName :: forall w i. Maybe String -&gt; HH.HTML w i
renderName mbName = maybeElem mbName \name -&gt; HH.text name
</code></pre>
<p>Second, you may want to render some HTML only if a condition is true, without computing the HTML if it fails the condition. You can do this by hiding its evaluation behind a function so the HTML is only computed when the condition is true.</p>
<pre><code class="language-purs">whenElem :: forall w i. Boolean -&gt; (Unit -&gt; HH.HTML w i) -&gt; HH.HTML w i
whenElem cond f = if cond then f unit else HH.text &quot;&quot;

-- Render the old number, but only if it is different from the new number
renderOld :: forall w i. { old :: Number, new :: Number } -&gt; HH.HTML w i
renderOld { old, new } = 
  whenElem (old /= new) \_ -&gt; 
    HH.div_ [ HH.text $ show old ]
</code></pre>
<p>Now that we've explored a few ways to work with HTML, let's learn more about the types that describe it.</p>
<h2><a class="header" href="#html-types" id="html-types">HTML Types</a></h2>
<p>So far we've written HTML without type signatures. But when you write Halogen HTML in your application you'll include the type signatures.</p>
<h3><a class="header" href="#html-w-i" id="html-w-i"><code>HTML w i</code></a></h3>
<p><code>HTML</code> is the core type for HTML in Halogen. It is used for HTML elements that are not tied to a particular kind of component. For example, it's used as the type for the <code>h1</code>, <code>text</code>, and <code>button</code> elements we've seen so far. You can also use this type when defining your own custom HTML elements.</p>
<p>The <code>HTML</code> type takes two type parameters: <code>w</code>, which stands for &quot;widget&quot; and describes what components can be used in the HTML, and <code>i</code>, which stands for &quot;input&quot; and represents the type used to handle DOM events.</p>
<p>When you write helper functions for Halogen HTML that don't need to respond to DOM events, then you will typically use the <code>HTML</code> type without specifying what <code>w</code> and <code>i</code> are. For example, this helper function lets you create a button, given a label:</p>
<pre><code class="language-purs">primaryButton :: forall w i. String -&gt; HH.HTML w i
primaryButton label =
  HH.button
    [ HP.classes [ HH.ClassName &quot;primary&quot; ] ]
    [ HH.text label ]
</code></pre>
<p>You could also accept HTML as the label instead of accepting just a string:</p>
<pre><code class="language-purs">primaryButton :: forall w i. HH.HTML w i -&gt; HH.HTML w i
primaryButton label =
  HH.button
    [ HP.classes [ HH.ClassName &quot;primary&quot; ] ]
    [ label ]
</code></pre>
<p>Of course, being a button, you probably want to do something when it's clicked. Don't worry -- we'll cover handling DOM events in the next chapter!</p>
<h3><a class="header" href="#componenthtml-and-plainhtml" id="componenthtml-and-plainhtml"><code>ComponentHTML</code> and <code>PlainHTML</code></a></h3>
<p>There are two other HTML types you will commonly see in Halogen applications.</p>
<p><code>ComponentHTML</code> is used when you write HTML that is meant to work with a particular type of component. It can also be used outside of components, but it is most commonly used within them. We'll learn more about this type in the next chapter.</p>
<p><code>PlainHTML</code> is a more restrictive version of <code>HTML</code> that's used for HTML that doesn't contain components and doesn't respond to events in the DOM. The type lets you hide <code>HTML</code>'s two type parameters, which is convenient when you're passing HTML around as a value. However, if you want to combine values of this type with other HTML that does respond to DOM events or contain components, you'll need to convert it with <code>fromPlainHTML</code>.</p>
<h3><a class="header" href="#iprop" id="iprop"><code>IProp</code></a></h3>
<p>When you look up functions from the <code>Halogen.HTML.Properties</code> and <code>Halogen.HTML.Events</code> modules, you'll see the <code>IProp</code> type featured prominently. For example, here's the <code>placeholder</code> function which will let you set the string placeholder property on a text field:</p>
<pre><code class="language-purs">placeholder :: forall r i. String -&gt; IProp (placeholder :: String | r) i
placeholder = prop (PropName &quot;placeholder&quot;)
</code></pre>
<p>The <code>IProp</code> type is used for events and properties. It uses a row type to uniquely identify particular events and properties; when you then use one of these properties with a Halogen HTML element, Halogen is able to verify whether the element you're applying the property to actually supports it.</p>
<p>This is possible because Halogen HTML elements also carry a row type which lists all the properties and events that it can support. When you apply a property or event to the element, Halogen looks up in the HTML element's row type whether or not it supports the property or event.</p>
<p>This helps ensure your HTML is well-formed. For example, <code>&lt;div&gt;</code> elements do not support the <code>placeholder</code> property according to the DOM spec. Accordingly, if you try to give a <code>div</code> a <code>placeholder</code> property in Halogen you'll get a compile-time error:</p>
<pre><code class="language-purs">-- ERROR: Could not match type ( placeholder :: String | r )
-- with type ( accessKey :: String, class :: String, ... )
html = HH.div [ HP.placeholder &quot;blah&quot; ] [ ]
</code></pre>
<p>This error tells you that you've tried to use a property with an element that doesn't support it. It first lists the property you tried to use, and then it lists the properties that the element <em>does</em> support. Another example of Halogen's type safety in action!</p>
<h3><a class="header" href="#adding-missing-properties" id="adding-missing-properties">Adding missing properties</a></h3>
<p>HTML is a <a href="https://html.spec.whatwg.org/multipage">living standard</a> that is constantly being revised. Halogen tries to keep up with these changes, but sometimes falls behind. (If you have any ideas for how we can automate the process of detecting these changes, please <a href="https://github.com/purescript-halogen/purescript-halogen/issues/685">let us know</a>).</p>
<p>You'll likely discover that some properties are missing in Halogen. For example, you may try to write:</p>
<pre><code class="language-purs">html = HH.iframe [ HP.sandbox &quot;allow-scripts&quot; ]
</code></pre>
<p>Only to receive this error:</p>
<pre><code>Unknown value HP.sandbox
</code></pre>
<p>Even though it seems like this property should be <a href="https://pursuit.purescript.org/packages/purescript-dom-indexed/docs/DOM.HTML.Indexed#t:HTMLiframe">supported</a>:</p>
<pre><code class="language-purs">type HTMLiframe = Noninteractive (height :: CSSPixel, name :: String, onLoad :: Event, sandbox :: String, src :: String, srcDoc :: String, width :: CSSPixel)
</code></pre>
<p>The solution is to write your own implementation of this missing property:</p>
<pre><code class="language-purs">sandbox :: forall r i. String -&gt; HH.IProp ( sandbox :: String | r ) i
sandbox = HH.prop (HH.PropName &quot;sandbox&quot;)
</code></pre>
<p>Then you can use it in your HTML element:</p>
<pre><code class="language-purs">html = HH.iframe [ sandbox &quot;allow-scripts&quot; ]
</code></pre>
<p>Please open an issue or PR to add this missing property. This is an easy way to contribute to Halogen.</p>
<h1><a class="header" href="#introducing-components" id="introducing-components">Introducing Components</a></h1>
<p>Halogen HTML is one basic building block of Halogen applications. But pure functions that produce HTML lack many essential features that a real world application needs: state that represents values over time, effects for things like network requests, and the ability to respond to DOM events (for example, when a user clicks a button).</p>
<p>Halogen components accept input and produce Halogen HTML, like the functions we've seen so far. Unlike functions, though, components maintain internal state, can update their state or perform effects in response to events, and can communicate with other components.</p>
<p>Halogen uses a component architecture. That means that Halogen uses components to let you split your UI into independent, reusable pieces and think about each piece in isolation. You can then combine components together to produce sophisticated applications.</p>
<p>For example, every Halogen application is made up of at least one component, which is called the &quot;root&quot; component. Halogen components can contain further components, and the resulting tree of components comprises your Halogen application.</p>
<p>In this chapter we'll learn most of the essential types and functions for writing Halogen components. For a beginner, this is the hardest chapter in the guide because many of these concepts will be brand-new. Don't worry if it feels overwhelming the first time you read it! You'll use these types and functions over and over again when you write Halogen applications, and they soon become second nature. If you're having a hard time with the chapter, try reading it again while building a simple component other than the one described here.</p>
<p>In this chapter we'll also see more examples of Halogen's declarative style of programming. When you write a component you're responsible for describing what UI should exist for any given internal state. Halogen, under the hood, updates the actual DOM elements to match your desired UI.</p>
<h2><a class="header" href="#a-tiny-example" id="a-tiny-example">A Tiny Example</a></h2>
<p>We have already seen a simple example of a component: a counter that can be incremented or decremented.</p>
<pre><code class="language-purs">module Main where

import Prelude

import Halogen as H
import Halogen.HTML as HH
import Halogen.HTML.Events as HE

data Action = Increment | Decrement

component =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval H.defaultEval { handleAction = handleAction }
    }
  where
  initialState _ = 0

  render state =
    HH.div_
      [ HH.button [ HE.onClick \_ -&gt; Decrement ] [ HH.text &quot;-&quot; ]
      , HH.text (show state)
      , HH.button [ HE.onClick \_ -&gt; Increment ] [ HH.text &quot;+&quot; ]
      ]

  handleAction = case _ of
    Decrement -&gt;
      H.modify_ \state -&gt; state - 1

    Increment -&gt;
      H.modify_ \state -&gt; state + 1
</code></pre>
<p>This component maintains an integer as its internal state, and updates that state in response to click events on the two buttons.</p>
<p>This component works, but in a real world application we wouldn't leave all the types unspecified. Let's rebuild this component from scratch with all the types it uses.</p>
<h2><a class="header" href="#building-a-basic-component-with-types" id="building-a-basic-component-with-types">Building a Basic Component (With Types)</a></h2>
<p>A typical Halogen component accepts input, maintains an internal state, produces Halogen HTML from that state, and updates its state or performs effects in response to events. In this case we don't need to perform any effects, but we'll cover them soon.</p>
<p>Let's break down each part of our component, assigning types along the way.</p>
<h3><a class="header" href="#input" id="input">Input</a></h3>
<p>Halogen components can accept input from a parent component or the root of the application. If you think of a component as a function, then input is the function's argument.</p>
<p>If your component takes input, then you should describe it with a type. For example, a component that accepts an integer as input would use this type:</p>
<pre><code class="language-purs">type Input = Int
</code></pre>
<p>Our counter doesn't require any input, so we have two choices. First, we can just say that our input type is <code>Unit</code>, meaning that we'll just take a dummy value and throw it away:</p>
<pre><code class="language-purs">type Input = Unit
</code></pre>
<p>Second, and more commonly, anywhere our input type shows up in our component we can simply leave it as a type variable: <code>forall i. ...</code>. It's perfectly fine to use either approach, but from here on out we'll use type variables to represent types our component isn't using.</p>
<h3><a class="header" href="#state" id="state">State</a></h3>
<p>Halogen components maintain an internal state over time, which is used to drive the component's behavior and to produce HTML. Our counter component maintains the current count, an integer, so we'll use that as our state type:</p>
<pre><code class="language-purs">type State = Int
</code></pre>
<p>Our component needs to also produce an initial state value. All Halogen components require an <code>initialState</code> function which produces the initial state from the input value:</p>
<pre><code class="language-purs">initialState :: Input -&gt; State
</code></pre>
<p>Our counter component doesn't use its input, so our <code>initialState</code> function won't use an input type and will instead just leave that type variable open. Our counter should start at 0 when the component runs.</p>
<pre><code class="language-purs">initialState :: forall input. input -&gt; State
initialState _ = 0
</code></pre>
<h3><a class="header" href="#actions" id="actions">Actions</a></h3>
<p>Halogen components can update state, perform effects, and communicate with other components in response to events that arise internally. Components use an &quot;action&quot; type to describe what kinds of things a component can do in response to internal events.</p>
<p>Our counter has two internal events:</p>
<ol>
<li>a click event on the &quot;-&quot; button to decrement the count</li>
<li>a click event on the &quot;+&quot; button to increment the count.</li>
</ol>
<p>We can describe what our component should do in response to these events using a data type we'll call <code>Action</code>:</p>
<pre><code class="language-purs">data Action = Increment | Decrement
</code></pre>
<p>This type signifies that our component is capable of incrementing and decrementing. In a moment, we'll see this type used in our HTML -- another example of Halogen's declarative nature.</p>
<p>Just like how our state type had to be paired with an <code>initialState</code> function that describes how to produce a <code>State</code> value, our <code>Action</code> type should be paired with a function called <code>handleAction</code> that describes what to do when one of these actions occurs.</p>
<pre><code class="language-purs">handleAction :: forall output m. Action -&gt; H.HalogenM State Action () output m Unit
</code></pre>
<p>As with our input type, we can leave type variables open for types that we aren't using.</p>
<ul>
<li>The type <code>()</code> means our component has no child components. We could also leave it open as a type variable because we aren't using it -- <code>slots</code>, by convention -- but <code>()</code> is so short you'll see this type commonly used instead.</li>
<li>The <code>output</code> type parameter is only used when your component communicates with a parent.</li>
<li>The <code>m</code> type parameter is only relevant when your component performs effects.</li>
</ul>
<p>Since our counter has no child components we'll use <code>()</code> to describe them, and because it doesn't communicate with a parent or perform effects we'll leave the <code>output</code> and <code>m</code> type variables open.</p>
<p>Here's the <code>handleAction</code> function for our counter:</p>
<pre><code class="language-purs">handleAction :: forall output m. Action -&gt; H.HalogenM State Action () output m Unit
handleAction = case _ of
  Decrement -&gt;
    H.modify_ \state -&gt; state - 1

  Increment -&gt;
    H.modify_ \state -&gt; state + 1
</code></pre>
<p>Our <code>handleAction</code> function responds to <code>Decrement</code> by reducing our state variable by 1, and to <code>Increment</code> by increasing our state variable by 1. Halogen provides several update functions you can use in your <code>handleAction</code> function; these ones are commonly used:</p>
<ul>
<li><code>modify</code> allows you to update the state, given the previous state, returning the new state</li>
<li><code>modify_</code> is the same as <code>modify</code>, but it doesn't return the new state (thus you don't have to explicitly discard the result, as you would with <code>modify</code>)</li>
<li><code>get</code> allows you to retrieve the current state</li>
<li><code>gets</code> allows you to retrieve the current state and also apply a function to it (most commonly, <code>_.fieldName</code> to retrieve a particular field from a record)</li>
</ul>
<p>We'll talk more about <code>HalogenM</code> when we talk about performing effects. Our counter doesn't perform effects, so all we need are the state update functions.</p>
<h3><a class="header" href="#rendering" id="rendering">Rendering</a></h3>
<p>Halogen components produce HTML from their state using a function called <code>render</code>. The render function runs every time the state changes. This is what makes Halogen declarative: for any given state, you describe the UI that it corresponds to. Halogen handles the workload of ensuring that state changes always result in the UI you described.</p>
<p>Render functions in Halogen are pure, which means that you can't do things like get the current time, make network requests, or anything like that during rendering. All you can do is produce HTML for your state value.</p>
<p>When we look at the type of our render function we can see the <code>ComponentHTML</code> type we touched on last chapter. This type is a more specialized version of the <code>HTML</code> type, meant specifically for HTML produced in components. Once again, we'll use <code>()</code> and leave <code>m</code> open because they are only relevant when using child components, which we'll cover in a later chapter.</p>
<pre><code class="language-purs">render :: forall m. State -&gt; H.ComponentHTML Action () m
</code></pre>
<p>Now that we're working with our render function, we're back to the Halogen HTML that should be familiar from the last chapter! You can write regular HTML in <code>ComponentHTML</code> just like we did last chapter:</p>
<pre><code class="language-purs">import Halogen.HTML.Events

render :: forall m. State -&gt; H.ComponentHTML Action () m
render state =
  HH.div_
    [ HH.button [ HE.onClick \_ -&gt; Decrement ] [ HH.text &quot;-&quot; ]
    , HH.text (show state)
    , HH.button [ HE.onClick \_ -&gt; Increment ] [ HH.text &quot;+&quot; ]
    ]
</code></pre>
<h4><a class="header" href="#handling-events" id="handling-events">Handling Events</a></h4>
<p>We can now see how to handle events in Halogen. First, you write the event handler in the properties array along with any other properties, attributes, and refs you might need. Then, you associate the event handler with an <code>Action</code> that your component knows how to handle. Finally, when the event occurs, your <code>handleAction</code> function is called to handle the event.</p>
<p>You might be curious about why we provided an anonymous function to <code>onClick</code>. To see why, we can look at the actual type of <code>onClick</code>:</p>
<pre><code class="language-purs">onClick
  :: forall row action
   . (MouseEvent -&gt; action)
  -&gt; IProp (onClick :: MouseEvent | row) action

-- Specialized to our component
onClick
  :: forall row
   . (MouseEvent -&gt; Action)
  -&gt; IProp (onClick :: MouseEvent | row) Action
</code></pre>
<p>In Halogen, event handlers take as their first argument a callback. This callback receives the DOM event that occurred (in the case of a click event, that's a <code>MouseEvent</code>), which contains some metadata you may want to use, and is then responsible for returning an action that Halogen should run in response to the event. In our case, we won't inspect the event itself, so we throw the argument away and return the action we want to run (<code>Increment</code> or <code>Decrement</code>).</p>
<p>The <code>onClick</code> function then returns a value of type <code>IProp</code>. You should remember <code>IProp</code> from the previous chapter. As a refresher, Halogen HTML elements specify a list of what properties and events they support. Properties and events in turn specify their type. Halogen is then able to ensure that you never use a property or event on an element that doesn't support it. In this case buttons do support <code>onClick</code> events, so we're good to go!</p>
<p>In this simple example, the <code>MouseEvent</code> parameter is ignored by the handler function passed to <code>onClick</code>, since the action is completely determined by which button receives the click.  We will talk about accessing the event itself after we have looked at effects in section 3 of this guide.</p>
<h3><a class="header" href="#bringing-it-all-together" id="bringing-it-all-together">Bringing It All Together</a></h3>
<p>Let's bring each of our types and functions back together to produce our counter component -- this time with types specified. Let's revisit the types and functions that we wrote:</p>
<pre><code class="language-purs">-- This can be specified if your component takes input, or you can leave
-- the type variable open if your component doesn't.
type Input = Unit

type State = Int

initialState :: forall input. input -&gt; State
initialState = ...

data Action = Increment | Decrement

handleAction :: forall output m. Action -&gt; H.HalogenM State Action () output m Unit
handleAction = ...

render :: forall m. State -&gt; H.ComponentHTML Action () m
render = ...
</code></pre>
<p>These types and functions are the core building blocks of a typical Halogen component. But they aren't sufficient on their own like this -- we need to bring them all together in one place.</p>
<p>We'll do that using the <code>H.mkComponent</code> function. This function takes a <code>ComponentSpec</code>, which is a record containing an <code>initialState</code>, <code>render</code>, and <code>eval</code> function, and produces a <code>Component</code> from it:</p>
<pre><code class="language-purs">component =
  H.mkComponent
    { -- First, we provide our function that describes how to produce the first state
      initialState
      -- Then, we provide our function that describes how to produce HTML from the state
    , render
      -- Finally, we provide our function that describes how to handle actions that
      -- occur while the component is running, which updates the state.
    , eval: H.mkEval $ H.defaultEval { handleAction = handleAction }
    }
</code></pre>
<p>We'll talk more about the <code>eval</code> function in future chapters. For the time being you can think of the <code>eval</code> function as defining how the component responds to events; for now, the only kind of events we care about are actions, and so the only function we'll use is <code>handleAction</code>.</p>
<p>Our component is now complete, but we're missing one last type definition: our component type.</p>
<h3><a class="header" href="#the-hcomponent-type" id="the-hcomponent-type">The <code>H.Component</code> Type</a></h3>
<p>The <code>mkComponent</code> function produces a component from a <code>ComponentSpec</code>, which is a record of the functions that Halogen needs to run a component. We'll get into more detail about this type in a subsequent chapter.</p>
<pre><code class="language-purs">mkComponent :: H.ComponentSpec ... -&gt; H.Component query input output m
</code></pre>
<p>The resulting component has the type <code>H.Component</code>, which itself takes four type parameters that describe the public interface of the component. Our component doesn't communicate with parent components or child components, so it doesn't use any of these type variables. Still, we'll briefly step through them now so you know what's coming in subsequent chapters.</p>
<ol>
<li>The first parameter <code>query</code> represents a way that parent components can communicate with this component. We will talk about it more when we talk about parent and child components.</li>
<li>The second parameter <code>input</code> represents the input our component accepts. In our case, the component doesn't accept any input, so we'll leave this variable open.</li>
<li>The third parameter <code>output</code> represents a way that this component can communicate with its parent component. We'll talk about it more when we talk about parent and child components.</li>
<li>The final parameter, <code>m</code>, represents the monad that can be used to run effects in the component. Our component doesn't run any effects, so we'll leave this variable open.</li>
</ol>
<p>Our counter component can therefore be specified by leaving all of the <code>H.Component</code> type variables open.</p>
<h2><a class="header" href="#the-final-product" id="the-final-product">The Final Product</a></h2>
<p>That was a lot to take in! We've finally got our counter component fully specified with types. If you can comfortably build components like this one, you're most of the way to a thorough understanding of building Halogen components in general. The rest of this guide will build on top of your understanding of state, actions, and rendering HTML.</p>
<p>We've added a <code>main</code> function that runs our Halogen application so that you can try this example out by pasting it into <a href="https://try.purescript.org">Try PureScript</a>. We'll cover how to run Halogen applications in a later chapter -- for now you can ignore the <code>main</code> function and focus on the component we've defined.</p>
<pre><code class="language-purs">module Main where

import Prelude

import Effect (Effect)
import Halogen as H
import Halogen.Aff as HA
import Halogen.HTML as HH
import Halogen.HTML.Events as HE
import Halogen.VDom.Driver (runUI)

main :: Effect Unit
main = HA.runHalogenAff do
  body &lt;- HA.awaitBody
  runUI component unit body

type State = Int

data Action = Increment | Decrement

component :: forall query input output m. H.Component query input output m
component =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval H.defaultEval { handleAction = handleAction }
    }

initialState :: forall input. input -&gt; State
initialState _ = 0

render :: forall m. State -&gt; H.ComponentHTML Action () m
render state =
  HH.div_
    [ HH.button [ HE.onClick \_ -&gt; Decrement ] [ HH.text &quot;-&quot; ]
    , HH.text (show state)
    , HH.button [ HE.onClick \_ -&gt; Increment ] [ HH.text &quot;+&quot; ]
    ]

handleAction :: forall output m. Action -&gt; H.HalogenM State Action () output m Unit
handleAction = case _ of
  Decrement -&gt;
    H.modify_ \state -&gt; state - 1

  Increment -&gt;
    H.modify_ \state -&gt; state + 1
</code></pre>
<h1><a class="header" href="#performing-effects" id="performing-effects">Performing Effects</a></h1>
<p>We've covered a lot of ground so far. You know how to write Halogen HTML. You can define components that respond to user interactions and model each part of the component in types. With this foundation we can move on to another vital tool when writing applications: performing effects.</p>
<p>In this chapter we'll explore how to perform effects in your component through two examples: generating random numbers and making HTTP requests. Once you know how to perform effects you are well on your way to mastering Halogen fundamentals.</p>
<p>Before we start, it's important to know that you can only perform effects during evaluation, which means functions like <code>handleAction</code> which use the type <code>HalogenM</code>. You can't perform effects when you produce your initial state or during rendering. Since you can only perform effects when you're within <code>HalogenM</code>, let's briefly learn more about it before diving in to the examples.</p>
<h2><a class="header" href="#the-halogenm-type" id="the-halogenm-type">The <code>HalogenM</code> Type</a></h2>
<p>If you recall from last chapter, the <code>handleAction</code> function returns a type called <code>HalogenM</code>. Here's the <code>handleAction</code> we wrote:</p>
<pre><code class="language-purs">handleAction :: forall output m. Action -&gt; HalogenM State Action () output m Unit
</code></pre>
<p><code>HalogenM</code> is a crucial part of Halogen, often called the &quot;eval&quot; monad. This monad enables Halogen features like state, forking threads, starting subscriptions, and more. But it's quite limited, concerning itself only with Halogen-specific features. In fact, Halogen components have no built-in mechanisms for effects!</p>
<p>Instead, Halogen lets you choose what monad you would like to use with <code>HalogenM</code> in your component. You gain access to all the capabilities of <code>HalogenM</code> <em>and also</em> whatever capabilities your chosen monad supports. This is represented with the type parameter <code>m</code>, which stands for &quot;monad&quot;.</p>
<p>A component that only uses Halogen-specific features can leave this type parameter open. Our counter, for example, only updated state. But a component that performs effects can use the <code>Effect</code> or <code>Aff</code> monads, or you can supply a custom monad of your own.</p>
<p>This <code>handleAction</code> is able to use functions from <code>HalogenM</code> like <code>modify_</code> and can also use effectful functions from <code>Effect</code>:</p>
<pre><code class="language-purs">handleAction :: forall output. Action -&gt; HalogenM State Action () output Effect Unit
</code></pre>
<p>This one can use functions from <code>HalogenM</code> and also effectful functions from <code>Aff</code>:</p>
<pre><code class="language-purs">handleAction :: forall output. Action -&gt; HalogenM State Action () output Aff Unit
</code></pre>
<p>It is more common in Halogen to use constraints on the type parameter <code>m</code> to describe what the monad can do rather than choose a specific monad, which allows you to mix several monads together as your application grows. For example, most Halogen apps would use functions from <code>Aff</code> via this type signature:</p>
<pre><code class="language-purs">handleAction :: forall output m. MonadAff m =&gt; Action -&gt; HalogenM State Action () output m Unit
</code></pre>
<p>This lets you do everything the hardcoded <code>Aff</code> type did, but it also lets you mix in other constraints too.</p>
<p>One last thing: when you choose a monad for your component it will show up in your <code>HalogenM</code> type, your <code>Component</code> type, and, if you are using child components, in your <code>ComponentHTML</code> type:</p>
<pre><code class="language-purs">component :: forall query input output m. MonadAff m =&gt; H.Component query input output m

handleAction :: forall output m. MonadAff m =&gt; Action -&gt; HalogenM State Action () output m Unit

-- We aren't using child components, so we don't have to use the constraint here, but
-- we'll learn about when it's required in the parent &amp; child components chapter.
render :: forall m. State -&gt; H.ComponentHTML Action () m
</code></pre>
<h2><a class="header" href="#an-effect-example-random-numbers" id="an-effect-example-random-numbers">An <code>Effect</code> Example: Random Numbers</a></h2>
<p>Let's create a new, simple component that generates a new random number each time you click a button. As you read through the example, notice how it uses the same types and functions that we used to write our counter. Over time you'll become used to scanning the state, action, and other types of a Halogen component to get a gist of what it does, and familiar with standard functions like <code>initialState</code>, <code>render</code>, and <code>handleAction</code>.</p>
<blockquote>
<p>You can paste this example into <a href="https://try.purescript.org">Try Purescript</a> to explore it interactively. You can also see and run the <a href="https://github.com/purescript-halogen/purescript-halogen/tree/master/examples/effects-effect-random">full example code</a> from the <code>examples</code> directory in this repository.</p>
</blockquote>
<p>Notice that we don't perform any effects in our <code>initialState</code> or <code>render</code> functions -- for example, we initialize our state to <code>Nothing</code> rather than generate a random number for our initial state -- but we're free to perform effects in our <code>handleAction</code> function (which uses the <code>HalogenM</code> type).</p>
<pre><code class="language-purs">module Main where

import Prelude

import Data.Maybe (Maybe(..), maybe)
import Effect (Effect)
import Effect.Class (class MonadEffect)
import Effect.Random (random)
import Halogen as H
import Halogen.Aff (awaitBody, runHalogenAff)
import Halogen.HTML as HH
import Halogen.HTML.Events as HE
import Halogen.VDom.Driver (runUI)

main :: Effect Unit
main = runHalogenAff do
  body &lt;- awaitBody
  runUI component unit body

type State = Maybe Number

data Action = Regenerate

component :: forall query input output m. MonadEffect m =&gt; H.Component query input output m
component =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval $ H.defaultEval { handleAction = handleAction }
    }

initialState :: forall input. input -&gt; State
initialState _ = Nothing

render :: forall m. State -&gt; H.ComponentHTML Action () m
render state = do
  let value = maybe &quot;No number generated yet&quot; show state
  HH.div_
    [ HH.h1_
        [ HH.text &quot;Random number&quot; ]
    , HH.p_
        [ HH.text (&quot;Current value: &quot; &lt;&gt; value) ]
    , HH.button
        [ HE.onClick \_ -&gt; Regenerate ]
        [ HH.text &quot;Generate new number&quot; ]
    ]

handleAction :: forall output m. MonadEffect m =&gt; Action -&gt; H.HalogenM State Action () output m Unit
handleAction = case _ of
  Regenerate -&gt; do
    newNumber &lt;- H.liftEffect random
    H.modify_ \_ -&gt; Just newNumber
</code></pre>
<p>As you can see, a component that performs effects is not much different from a component that doesn't! We've only done two things:</p>
<ol>
<li>We added a <code>MonadEffect</code> constraint to the <code>m</code> type parameter for our component <em>and</em> for our <code>handleAction</code> function. We don't need the constraint for our render function because we don't have any child components.</li>
<li>We actually <em>used</em> an effect for the first time: the <code>random</code> function, which comes from <code>Effect.Random</code>.</li>
</ol>
<p>Let's break down using this effect a little more.</p>
<pre><code class="language-purs">--                          [1]
handleAction :: forall output m. MonadEffect m =&gt; Action -&gt; H.HalogenM State Action () output m Unit
handleAction = case _ of
  Regenerate -&gt; do
    newNumber &lt;- H.liftEffect random -- [2]
    H.modify_ \_ -&gt; Just newNumber   -- [3]
</code></pre>
<ol>
<li>We have constrained our <code>m</code> type parameter to say we support any monad, so long as that monad supports <code>MonadEffect</code>. It's another way to say &quot;We need to be able to use <code>Effect</code> functions in our evaluation code.&quot;</li>
<li>The <code>random</code> function has the type <code>Effect Number</code>. But we can't use it directly: our component doesn't support <code>Effect</code> but rather <em>any</em> monad <code>m</code> so long as that monad can run effects from <code>Effect</code>. It's a subtle difference, but in the end we require the <code>random</code> function to have the type <code>MonadEffect m =&gt; m Number</code> instead of being <code>Effect</code> directly. Fortunately, we can convert any <code>Effect</code> type to <code>MonadEffect m =&gt; m</code> using the <code>liftEffect</code> function. This is a common pattern in Halogen, so keep <code>liftEffect</code> in mind if you're using <code>MonadEffect</code>.</li>
<li>The <code>modify_</code> function lets you update state, and it comes directly from <code>HalogenM</code> with the other state update functions. Here we use it to write the new random number to our state.</li>
</ol>
<p>This is a nice example of how you can freely interleave effects from <code>Effect</code> with Halogen-specific functions like <code>modify_</code>. Let's do it again, this time using the <code>Aff</code> monad for asynchronous effects.</p>
<h2><a class="header" href="#an-aff-example-http-requests" id="an-aff-example-http-requests">An <code>Aff</code> Example: HTTP Requests</a></h2>
<p>It's common to fetch information from elsewhere on the Internet. For example, let's say we'd like to work with GitHub's API to fetch users. We'll use the <a href="https://pursuit.purescript.org/packages/purescript-affjax"><code>affjax</code></a> package to make our requests, which itself relies on the <code>Aff</code> monad for asynchronous effects.</p>
<p>This example is even more interesting, though: we'll also use the <code>preventDefault</code> function to prevent form submission from refreshing the page, which runs in <code>Effect</code>. That means our example shows how you can interleave different effects together (<code>Effect</code> and <code>Aff</code>) along with Halogen functions (<code>HalogenM</code>).</p>
<blockquote>
<p>As with the Random example, you can paste this example into <a href="https://try.purescript.org">Try Purescript</a> to explore it interactively. You can also see and run the <a href="https://github.com/purescript-halogen/purescript-halogen/tree/master/examples/effects-aff-ajax">full example code</a> from the <code>examples</code> directory in this repository.</p>
</blockquote>
<p>This component definition should start to look familiar. We define our <code>State</code> and <code>Action</code> types and implement our <code>initialState</code>, <code>render</code>, and <code>handleAction</code> functions. We bring them together into our component spec and turn them into a valid component <code>H.mkComponent</code>.</p>
<p>Once again, notice that our effects are concentrated in the <code>handleAction</code> function and no effects are performed when making the initial state or rendering Halogen HTML.</p>
<pre><code class="language-purs">module Main where

import Prelude

import Affjax.Web as AX
import Affjax.ResponseFormat as AXRF
import Data.Either (hush)
import Data.Maybe (Maybe(..))
import Effect (Effect)
import Effect.Aff.Class (class MonadAff)
import Halogen as H
import Halogen.Aff (awaitBody, runHalogenAff)
import Halogen.HTML as HH
import Halogen.HTML.Events as HE
import Halogen.HTML.Properties as HP
import Halogen.VDom.Driver (runUI)
import Web.Event.Event (Event)
import Web.Event.Event as Event

main :: Effect Unit
main = runHalogenAff do
  body &lt;- awaitBody
  runUI component unit body

type State =
  { loading :: Boolean
  , username :: String
  , result :: Maybe String
  }

data Action
  = SetUsername String
  | MakeRequest Event

component :: forall query input output m. MonadAff m =&gt; H.Component query input output m
component =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval $ H.defaultEval { handleAction = handleAction }
    }

initialState :: forall input. input -&gt; State
initialState _ = { loading: false, username: &quot;&quot;, result: Nothing }

render :: forall m. State -&gt; H.ComponentHTML Action () m
render st =
  HH.form
    [ HE.onSubmit \ev -&gt; MakeRequest ev ]
    [ HH.h1_ [ HH.text &quot;Look up GitHub user&quot; ]
    , HH.label_
        [ HH.div_ [ HH.text &quot;Enter username:&quot; ]
        , HH.input
            [ HP.value st.username
            , HE.onValueInput \str -&gt; SetUsername str
            ]
        ]
    , HH.button
        [ HP.disabled st.loading
        , HP.type_ HP.ButtonSubmit
        ]
        [ HH.text &quot;Fetch info&quot; ]
    , HH.p_
        [ HH.text $ if st.loading then &quot;Working...&quot; else &quot;&quot; ]
    , HH.div_
        case st.result of
          Nothing -&gt; []
          Just res -&gt;
            [ HH.h2_
                [ HH.text &quot;Response:&quot; ]
            , HH.pre_
                [ HH.code_ [ HH.text res ] ]
            ]
    ]

handleAction :: forall output m. MonadAff m =&gt; Action -&gt; H.HalogenM State Action () output m Unit
handleAction = case _ of
  SetUsername username -&gt; do
    H.modify_ _ { username = username, result = Nothing }

  MakeRequest event -&gt; do
    H.liftEffect $ Event.preventDefault event
    username &lt;- H.gets _.username
    H.modify_ _ { loading = true }
    response &lt;- H.liftAff $ AX.get AXRF.string (&quot;https://api.github.com/users/&quot; &lt;&gt; username)
    H.modify_ _ { loading = false, result = map _.body (hush response) }
</code></pre>
<p>This example is especially interesting because:</p>
<ol>
<li>It mixes together functions from multiple monads (<code>preventDefault</code> is <code>Effect</code>, <code>AX.get</code> is <code>Aff</code>, and <code>gets</code> and <code>modify_</code> are <code>HalogenM</code>). We're able to use <code>liftEffect</code> and <code>liftAff</code> along with our constraints to make sure everything plays well together.</li>
<li>We only have one constraint, <code>MonadAff</code>. That's because anything that can be run in <code>Effect</code> can also be run in <code>Aff</code>, so <code>MonadAff</code> implies <code>MonadEffect</code>.</li>
<li>We're making multiple state updates in one evaluation.</li>
</ol>
<p>That last point is especially important: when you modify state your component renders. That means that during this evaluation we:</p>
<ol>
<li>Set <code>loading</code> to <code>true</code>, which causes the component to re-render and display &quot;Working...&quot;</li>
<li>Set <code>loading</code> to <code>false</code> and update the result, which causes the component to re-render and display the result (if there was one).</li>
</ol>
<p>It's worth noting that because we're using <code>MonadAff</code> our request will not block the component from doing other work, and we don't have to deal with callbacks to get this async superpower. The computation we've written in <code>MakeRequest</code> simply suspends until we get the response and then proceeds to update the state the second time.</p>
<p>It's a smart idea to only modify state when necessary and to batch updates together if possible (like how we call <code>modify_</code> once to update both the <code>loading</code> and <code>result</code> fields). That helps make sure you're only re-rendering when needed.</p>
<h3><a class="header" href="#event-handling-revisited" id="event-handling-revisited">Event Handling Revisited</a></h3>
<p>There is a lot going on in this example, so it is worth concentrating for a moment on the new event-handling features which it introduces.  Unlike the simple click handlers of the button example, the handlers defined here do make use of the event data they are given:</p>
<ul>
<li>The value of the username input is used by the <code>onValueInput</code> handler (the <code>SetUsername</code> action).</li>
<li><code>preventDefault</code> is called on the event in the <code>onSubmit</code> handler (the <code>MakeRequest</code> action).</li>
</ul>
<p>The type of parameter passed to the handler depends on which function is used to attach it. Sometimes, as for <code>onValueInput</code>, the handler simply receives data extracted from the event - a <code>String</code> in this case. Most of the other <code>on...</code> functions set up a handler to receive the whole event, either as a value of type <code>Event</code>, or as a specialised type like <code>MouseEvent</code>. The details can be found in the <a href="https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.HTML.Events">module documentation for <code>Halogen.HTML.Events</code></a> on pursuit; the types and functions used for events can be found in the <a href="https://pursuit.purescript.org/packages/purescript-web-events">web-events</a> and <a href="https://pursuit.purescript.org/packages/purescript-web-uievents">web-uievents</a> packages.</p>
<h1><a class="header" href="#lifecycles-and-subscriptions" id="lifecycles-and-subscriptions">Lifecycles and Subscriptions</a></h1>
<p>The concepts you've learned so far cover the majority of Halogen components you'll write. Most components have internal state, render HTML elements, and respond by performing actions when users click, hover over, or otherwise interact with the rendered HTML.</p>
<p>But actions can arise internally from other kinds of events, too. Here are some common examples:</p>
<ol>
<li>You need to run an action when the component starts up (for example, you need to perform an effect to get your initial state) or when the component is removed from the DOM (for example, to clean up resources you acquired). These are called <strong>lifecycle events</strong>.</li>
<li>You need to run an action at regular intervals (for example, you need to perform an update every 10 seconds), or when an event arises from outside your rendered HTML (for example, you need to run an action when a key is pressed on the DOM window, or you need to handle events that occur in a third-party component like a text editor). These are handled by <strong>subscriptions</strong>.</li>
</ol>
<p>We'll learn about one other way actions can arise in a component when we learn about parent and child components in the next chapter. This chapter will focus on lifecycles and subscriptions.</p>
<h2><a class="header" href="#lifecycle-events" id="lifecycle-events">Lifecycle Events</a></h2>
<p>Every Halogen component has access to two lifecycle events:</p>
<ol>
<li>The component can evaluate an action when it is initialized (Halogen creates it)</li>
<li>The component can evaluate an action when it is finalized (Halogen removes it)</li>
</ol>
<p>We specify what action (if any) to run when the component is initialized and finalized as part of the <code>eval</code> function -- the same place where we've been providing the <code>handleAction</code> function. In the next section we'll get into more detail about what <code>eval</code> is, but first lets see an example of lifecycles in action.</p>
<p>The following example is nearly identical to our random number component, but with some important changes.</p>
<ol>
<li>We have added <code>Initialize</code> and <code>Finalize</code> in addition to our existing <code>Regenerate</code> action.</li>
<li>We've expanded our <code>eval</code> to include an <code>initialize</code> field that states our <code>Initialize</code> action should be evaluated when the component initializes, and a <code>finalize</code> field that states our <code>Finalize</code> action should be evaluated when the component finalizes.</li>
<li>Since we have two new actions, we've added two new cases to our <code>handleAction</code> function to describe how to handle them.</li>
</ol>
<p>Try reading through the example:</p>
<pre><code class="language-purs">module Main where

import Prelude

import Data.Maybe (Maybe(..), maybe)
import Effect (Effect)
import Effect.Class (class MonadEffect)
import Effect.Class.Console (log)
import Effect.Random (random)
import Halogen as H
import Halogen.Aff as HA
import Halogen.HTML as HH
import Halogen.HTML.Events as HE
import Halogen.VDom.Driver (runUI)

main :: Effect Unit
main = HA.runHalogenAff do
  body &lt;- HA.awaitBody
  runUI component unit body

type State = Maybe Number

data Action
  = Initialize
  | Regenerate
  | Finalize

component :: forall query input output m. MonadEffect m =&gt; H.Component query input output m
component =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval $ H.defaultEval
        { handleAction = handleAction
        , initialize = Just Initialize
        , finalize = Just Finalize
        }
    }

initialState :: forall input. input -&gt; State
initialState _ = Nothing

render :: forall m. State -&gt; H.ComponentHTML Action () m
render state = do
  let value = maybe &quot;No number generated yet&quot; show state
  HH.div_
    [ HH.h1_
        [ HH.text &quot;Random number&quot; ]
    , HH.p_
        [ HH.text (&quot;Current value: &quot; &lt;&gt; value) ]
    , HH.button
        [ HE.onClick \_ -&gt; Regenerate ]
        [ HH.text &quot;Generate new number&quot; ]
    ]

handleAction :: forall output m. MonadEffect m =&gt; Action -&gt; H.HalogenM State Action () output m Unit
handleAction = case _ of
  Initialize -&gt; do
    handleAction Regenerate
    newNumber &lt;- H.get
    log (&quot;Initialized: &quot; &lt;&gt; show newNumber)

  Regenerate -&gt; do
    newNumber &lt;- H.liftEffect random
    H.put (Just newNumber)

  Finalize -&gt; do
    number &lt;- H.get
    log (&quot;Finalized! Last number was: &quot; &lt;&gt; show number)
</code></pre>
<p>When this component mounts we'll generate a random number and log it to the console. We'll keep regenerating random numbers as the user clicks the button, and when this component is removed from the DOM it will log the last number it had in state.</p>
<p>We made one other interesting change in this example: in our <code>Initialize</code> handler we called <code>handleAction Regenerate</code> -- we called <code>handleAction</code> recursively. It can be convenient to call actions from within other actions from time to time as we've done here. We could have also inlined <code>Regenerate</code>'s handler -- the following code does the same thing:</p>
<pre><code class="language-purs">  Initialize -&gt; do
    newNumber &lt;- H.liftEffect random
    H.put (Just newNumber)
    log (&quot;Initialized: &quot; &lt;&gt; show newNumber)
</code></pre>
<p>Before we move on to subscriptions, let's talk more about the <code>eval</code> function.</p>
<h2><a class="header" href="#the-eval-function-mkeval-and-evalspec" id="the-eval-function-mkeval-and-evalspec">The <code>eval</code> Function, <code>mkEval</code>, and <code>EvalSpec</code></a></h2>
<p>We've been using <code>eval</code> in all of our components, but so far we've only handled actions arising from our Halogen HTML via the <code>handleAction</code> function. But the <code>eval</code> function can describe <em>all</em> the ways our component can evaluate <code>HalogenM</code> code in response to events.</p>
<p>In the vast majority of cases you don't need to care much about all the types and functions involved in the component spec and eval spec described below, but we'll briefly break down the types so you have an idea of what's going on.</p>
<p>The <code>mkComponent</code> function takes a <code>ComponentSpec</code>, which is a record containing three fields:</p>
<pre><code class="language-purs">H.mkComponent
  { initialState :: input -&gt; state
  , render :: state -&gt; H.ComponentHTML action slots m
  , eval :: H.HalogenQ query action input ~&gt; H.HalogenM state action slots output m
  }
</code></pre>
<p>We've spent plenty of time with the <code>initialState</code> and <code>render</code> functions already. But the <code>eval</code> function may look strange -- what is <code>HalogenQ</code>, and how do functions like <code>handleAction</code> fit in? For now, we'll focus on the most common use of this function, but you can find the full details in the Concepts Reference.</p>
<p>The <code>eval</code> function describes how to handle events that arise in the component. It's usually constructed by applying the <code>mkEval</code> function to an <code>EvalSpec</code>, the same way we applied <code>mkComponent</code> to a <code>ComponentSpec</code> to produce a <code>Component</code>.</p>
<p>For convenience, Halogen provides an already-complete <code>EvalSpec</code> called <code>defaultEval</code>, which does nothing when an event arises in the component. By using this default value you can override just the values you care about, while leaving the rest of them doing nothing.</p>
<p>Here's how we've defined <code>eval</code> functions that only handle actions so far:</p>
<pre><code class="language-purs">H.mkComponent
  { initialState
  , render
  , eval: H.mkEval $ H.defaultEval { handleAction = handleAction }
  }

-- assuming we've defined a `handleAction` function in scope...
handleAction = ...
</code></pre>
<p><em>Note</em>: <code>initialState</code> and <code>render</code> are set using abbreviated <em>record pun</em> notation; however, <code>handleAction</code> cannot be set with a pun in this case because it is part of a <em>record update</em>. More information about <em>record pun</em> and <em>record update</em> syntax is available in the <a href="https://github.com/purescript/documentation/blob/master/language/Records.md#record-update">Records Language Reference</a>.</p>
<p>You can override more fields, if you need to. For example, if you need to support an initializer then you would override the <code>initialize</code> field too:</p>
<pre><code class="language-purs">H.mkComponent
  { initialState
  , render
  , eval: H.mkEval $ H.defaultEval
      { handleAction = handleAction
      , initialize = Just Initialize
      }
  }
</code></pre>
<p>Let's take a quick look at the full type of <code>EvalSpec</code>:</p>
<pre><code class="language-purs">type EvalSpec state query action slots input output m =
  { handleAction :: action -&gt; HalogenM state action slots output m Unit
  , handleQuery :: forall a. query a -&gt; HalogenM state action slots output m (Maybe a)
  , initialize :: Maybe action
  , receive :: input -&gt; Maybe action
  , finalize :: Maybe action
  }
</code></pre>
<p>The <code>EvalSpec</code> covers all the types available internally in your component. Fortunately, you don't need to specify this type anywhere -- you can just provide a record to <code>mkEval</code>. We'll cover the <code>handleQuery</code> and <code>receive</code> functions as well as the <code>query</code> and <code>output</code> types in the next chapter, as they're only relevant for child components.</p>
<p>Since in normal use you'll override specific fields from <code>defaultEval</code> rather than write out a whole eval spec yourself, let's also look at what <code>defaultEval</code> implements for each of these functions:</p>
<pre><code class="language-purs">defaultEval =
  { handleAction: const (pure unit)
  , handleQuery: const (pure Nothing) -- we'll learn about this when we cover child components
  , initialize: Nothing
  , receive: const Nothing -- we'll learn about this when we cover child components
  , finalize: Nothing
  }
</code></pre>
<p>Now, let's move to the other common source of internal events: subscriptions.</p>
<h2><a class="header" href="#subscriptions" id="subscriptions">Subscriptions</a></h2>
<p>Sometimes you need to handle events arising internally that don't come from a user interacting with the Halogen HTML you've rendered. Two common sources are time-based actions and events that happen on an element outside one you've rendered (like the browser window).</p>
<p>In Halogen these kinds of events can be created manually with the <a href="https://github.com/purescript-halogen/purescript-halogen-subscriptions"><code>halogen-subscriptions</code></a> library. Halogen components can subscribe to an <code>Emitter</code> by providing an action that should run when the emitter fires.</p>
<p>You can subscribe to events using functions from the <code>halogen-subscriptions</code> library, but Halogen provides a special helper function for subscribing to event listeners in the DOM called <code>eventListener</code>.</p>
<p>An <code>Emitter</code> produces a stream of actions, and your component will evaluate those actions so long as it remains subscribed to the emitter. It's common to create an emitter and subscribe to it when the component initializes, though you can subscribe or unsubscribe from an emitter at any time.</p>
<p>Let's see two examples of subscriptions in action: an <code>Aff</code>-based timer that counts the seconds since the component mounted and an event-listener-based stream that reports keyboard events on the document.</p>
<h3><a class="header" href="#implementing-a-timer" id="implementing-a-timer">Implementing a Timer</a></h3>
<p>Our first example will use an <code>Aff</code>-based timer to increment every second.</p>
<pre><code class="language-purs">module Main where

import Prelude

import Control.Monad.Rec.Class (forever)
import Data.Maybe (Maybe(..))
import Effect (Effect)
import Effect.Aff (Milliseconds(..))
import Effect.Aff as Aff
import Effect.Aff.Class (class MonadAff)
import Effect.Exception (error)
import Halogen as H
import Halogen.Aff as HA
import Halogen.HTML as HH
import Halogen.Subscription as HS
import Halogen.VDom.Driver (runUI)

main :: Effect Unit
main = HA.runHalogenAff do
  body &lt;- HA.awaitBody
  runUI component unit body

data Action = Initialize | Tick

type State = Int

component :: forall query input output m. MonadAff m =&gt; H.Component query input output m
component =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval $ H.defaultEval
        { handleAction = handleAction
        , initialize = Just Initialize
        }
    }

initialState :: forall input. input -&gt; State
initialState _ = 0

render :: forall m. State -&gt; H.ComponentHTML Action () m
render seconds = HH.text (&quot;You have been here for &quot; &lt;&gt; show seconds &lt;&gt; &quot; seconds&quot;)

handleAction :: forall output m. MonadAff m =&gt; Action -&gt; H.HalogenM State Action () output m Unit
handleAction = case _ of
  Initialize -&gt; do
    _ &lt;- H.subscribe =&lt;&lt; timer Tick
    pure unit

  Tick -&gt;
    H.modify_ \state -&gt; state + 1

timer :: forall m a. MonadAff m =&gt; a -&gt; m (HS.Emitter a)
timer val = do
  { emitter, listener } &lt;- H.liftEffect HS.create
  _ &lt;- H.liftAff $ Aff.forkAff $ forever do
    Aff.delay $ Milliseconds 1000.0
    H.liftEffect $ HS.notify listener val
  pure emitter
</code></pre>
<p>Almost all of this code should look familiar, but there are two new parts.</p>
<p>First, we've defined a reusable <code>Emitter</code> that will broadcast a value of our choice every second until it has no subscribers:</p>
<pre><code class="language-purs">timer :: forall m a. MonadAff m =&gt; a -&gt; m (HS.Emitter a)
timer val = do
  { emitter, listener } &lt;- H.liftEffect HS.create
  _ &lt;- H.liftAff $ Aff.forkAff $ forever do
    Aff.delay $ Milliseconds 1000.0
    H.liftEffect $ HS.notify listener val
  pure emitter
</code></pre>
<p>Unless you are creating emitters tied to event listeners in the DOM, you should use functions from the <code>halogen-subscriptions</code> library. Most commonly you'll use <code>HS.create</code> to create an emitter and a listener, but if you need to manually control unsubscription you can also use <code>HS.makeEmitter</code>.</p>
<p>Second, we use the <code>subscribe</code> function from Halogen to attach to the emitter, also providing the specific action we'd like to emit every second:</p>
<pre><code class="language-purs">  Initialize -&gt; do
    _ &lt;- H.subscribe =&lt;&lt; timer Tick
    pure unit
</code></pre>
<p>The <code>subscribe</code> function takes an <code>Emitter</code> as an argument and it returns a <code>SubscriptionId</code>. You can pass this <code>SubscriptionId</code> to the Halogen <code>unsubscribe</code> function at any point to end the subscription. Components automatically end any subscriptions it has when they finalize, so there's no requirement to unsubscribe here.</p>
<p>You may also be interested in the <a href="https://github.com/purescript-halogen/purescript-halogen/tree/master/examples/ace">Ace editor example</a>, which subscribes to events that happen inside a third-party JavaScript component and uses them to trigger actions in a Halogen component.</p>
<h3><a class="header" href="#using-event-listeners-as-subscriptions" id="using-event-listeners-as-subscriptions">Using Event Listeners As Subscriptions</a></h3>
<p>Another common reason to use subscriptions is when you need to react to events in the DOM that don't arise directly from HTML elements you control. For example, we might want to listen to events that happen on the document itself.</p>
<p>In the following example we subscribe to key events on the document, save any characters that are typed while holding the <code>Shift</code> key, and stop listening if the user hits the <code>Enter</code> key. It demonstrates using the <code>eventListener</code> function to attach an event listener and using the <code>H.unsubscribe</code> function to choose when to clean it up.</p>
<p>There is also a corresponding <a href="https://github.com/purescript-halogen/purescript-halogen/tree/master/examples/keyboard-input">example of keyboard input</a> in the examples directory.</p>
<pre><code class="language-purs">module Main where

import Prelude

import Data.Maybe (Maybe(..))
import Data.String as String
import Effect (Effect)
import Effect.Aff.Class (class MonadAff)
import Halogen as H
import Halogen.Aff as HA
import Halogen.HTML as HH
import Halogen.Query.Event (eventListener)
import Halogen.VDom.Driver (runUI)
import Web.Event.Event as E
import Web.HTML (window)
import Web.HTML.HTMLDocument as HTMLDocument
import Web.HTML.Window (document)
import Web.UIEvent.KeyboardEvent as KE
import Web.UIEvent.KeyboardEvent.EventTypes as KET

main :: Effect Unit
main = HA.runHalogenAff do
  body &lt;- HA.awaitBody
  runUI component unit body

type State = { chars :: String }

data Action
  = Initialize
  | HandleKey H.SubscriptionId KE.KeyboardEvent

component :: forall query input output m. MonadAff m =&gt; H.Component query input output m
component =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval $ H.defaultEval
        { handleAction = handleAction
        , initialize = Just Initialize
        }
    }

initialState :: forall input. input -&gt; State
initialState _ = { chars: &quot;&quot; }

render :: forall m. State -&gt; H.ComponentHTML Action () m
render state =
  HH.div_
    [ HH.p_ [ HH.text &quot;Hold down the shift key and type some characters!&quot; ]
    , HH.p_ [ HH.text &quot;Press ENTER or RETURN to clear and remove the event listener.&quot; ]
    , HH.p_ [ HH.text state.chars ]
    ]

handleAction :: forall output m. MonadAff m =&gt; Action -&gt; H.HalogenM State Action () output m Unit
handleAction = case _ of
  Initialize -&gt; do
    document &lt;- H.liftEffect $ document =&lt;&lt; window
    H.subscribe' \sid -&gt;
      eventListener
        KET.keyup
        (HTMLDocument.toEventTarget document)
        (map (HandleKey sid) &lt;&lt;&lt; KE.fromEvent)

  HandleKey sid ev
    | KE.shiftKey ev -&gt; do
        H.liftEffect $ E.preventDefault $ KE.toEvent ev
        let char = KE.key ev
        when (String.length char == 1) do
          H.modify_ \st -&gt; st { chars = st.chars &lt;&gt; char }

    | KE.key ev == &quot;Enter&quot; -&gt; do
        H.liftEffect $ E.preventDefault (KE.toEvent ev)
        H.modify_ _ { chars = &quot;&quot; }
        H.unsubscribe sid

    | otherwise -&gt;
        pure unit
</code></pre>
<p>In this example we used the <code>H.subscribe'</code> function, which passes the <code>SubscriptionId</code> to the emitter instead of returning it. This is an alternative that lets you keep the ID in the action type instead of the state, which can be more convenient.</p>
<p>We wrote our emitter right into our code to handle the <code>Initialize</code> action, which registers an event listener on the document and emits <code>HandleKey</code> every time a key is pressed.</p>
<p><code>eventListener</code> uses types from the <code>purescript-web</code> libraries for working with the DOM to manually construct an event listener:</p>
<pre><code class="language-purs">eventListener
  :: forall a
   . Web.Event.EventType
  -&gt; Web.Event.EventTarget.EventTarget
  -&gt; (Web.Event.Event -&gt; Maybe a)
  -&gt; HS.Emitter a
</code></pre>
<p>It takes a type of event to listen to (in our case: <code>keyup</code>), a target indicating where to listen for events (in our case: the <code>HTMLDocument</code> itself), and a callback function that transforms the events that occur into a type that should be emitted (in our case: we emit our <code>Action</code> type by capturing the event in the <code>HandleKey</code> constructor).</p>
<h2><a class="header" href="#wrapping-up" id="wrapping-up">Wrapping Up</a></h2>
<p>Halogen components use the <code>Action</code> type to handle various kinds of events that arise internally in a component. We've now seen all the common ways this can happen:</p>
<ol>
<li>User interaction with HTML elements we rendered</li>
<li>Lifecycle events</li>
<li>Subscriptions, whether via <code>Aff</code> and <code>Effect</code> functions or from event listeners on the DOM</li>
</ol>
<p>You now know all the essentials for using Halogen components in isolation. In the next chapter we'll learn how to combine Halogen components together into a tree of parent and child components.</p>
<h1><a class="header" href="#parent-and-child-components" id="parent-and-child-components">Parent and Child Components</a></h1>
<p>Halogen is an unopinionated UI library: it allows you to create declarative user interfaces without enforcing a particular architecture.</p>
<p>Our applications so far have consisted of a single Halogen component. You can build large applications as a single component and break the state and the <code>handleAction</code> and <code>render</code> functions into separate modules as the app grows. This lets you use the Elm architecture in Halogen.</p>
<p>However, Halogen supports architectures with arbitrarily deep trees of components. That means any component you write is allowed to contain more components, each with their own state and behaviors. Most Halogen applications use a component architecture in this way, including the <a href="https://github.com/thomashoneyman/purescript-halogen-realworld">Real World Halogen</a> app.</p>
<p>When you move from a single component to many components you begin to need mechanisms so that components can communicate with one another. Halogen gives us three ways for a parent and child component to communicate:</p>
<ol>
<li>A parent component can send <em>queries</em> to a child component, which either tell the child component to do something or request some information from it.</li>
<li>A parent component gives a child component the <em>input</em> it needs, which is re-sent every time the parent component renders.</li>
<li>A child component can emit <em>output messages</em> to the parent component, notifying it when an important event has occurred.</li>
</ol>
<p>These type parameters are represented in the <code>Component</code> type, and some are also found in the <code>ComponentHTML</code> and <code>HalogenM</code> types. For example, a component that supports queries, input, and output messages will have this <code>Component</code> type:</p>
<pre><code class="language-purs">component :: forall m. H.Component Query Input Output m
</code></pre>
<p>You can think of the ways a component can communicate with other components as its <em>public interface</em>, and the public interface shows up in the <code>Component</code> type.</p>
<p>In this chapter we'll learn about:</p>
<ol>
<li>How to render components in your Halogen HTML</li>
<li>The three ways that components communicate: queries, input, and output messages</li>
<li>Component slots, the <code>slot</code> function, and the <code>Slot</code> type, which make this communication type-safe</li>
</ol>
<p>We'll start by rendering a simple child component that has no queries or output messages. Then, we'll build up components that use these ways to communicate, ending with a final example that shows off a parent and child component using all of these mechanisms at once.</p>
<p>Try loading the example into Try PureScript to explore each of the communication mechanisms discussed in this chapter!</p>
<h2><a class="header" href="#rendering-components" id="rendering-components">Rendering Components</a></h2>
<p>We began this guide by writing functions that returned Halogen HTML elements. These functions could be used by other functions to build even larger trees of HTML elements.</p>
<p>When we started using components we began writing <code>render</code> functions. Conceptually, components produce Halogen HTML as their result via this function, though they can also maintain internal state and perform effects, among other things.</p>
<p>In fact, while we've only been using HTML elements when writing our <code>render</code> functions so far, we can also use <em>components</em> as if they were functions that produce HTML. The analogy is imperfect, but it can be a helpful mental model for understanding how to treat components when you are writing your <code>render</code> function.</p>
<p>When one component renders another, it's called the &quot;parent&quot; component and the component it renders is called the &quot;child&quot; component.</p>
<p>Let's see how we can render a component inside our <code>render</code> function, instead of only HTML elements as we've seen so far. We'll start by writing a component that uses a helper function to render a button. Then, we'll turn that helper function into its own component, and we'll adjust the parent component to render this new child component.</p>
<p>First, we'll write a component that uses a helper function to render some HTML:</p>
<pre><code class="language-purs">module Main where

import Prelude

import Halogen as H
import Halogen.HTML as HH

parent :: forall query input output m. H.Component query input output m
parent =
  H.mkComponent
    { initialState: identity
    , render
    , eval: H.mkEval H.defaultEval
    }
  where
  render :: forall state action. state -&gt; H.ComponentHTML action () m
  render _ = HH.div_ [ button { label: &quot;Click Me&quot; } ]

button :: forall w i. { label :: String } -&gt; HH.HTML w i
button { label } = HH.button [ ] [ HH.text label ]
</code></pre>
<p>This should look familiar. We have a simple component that renders a <code>div</code>, and a helper function, <code>button</code>, which renders a button given a label as input. As a note, our <code>parent</code> component leaves type variables open for our state and actions because it doesn't have an internal state and it doesn't have any actions.</p>
<p>Now, let's turn our <code>button</code> function into a component for demonstration purposes (in a real world app it would be too small for that):</p>
<pre><code class="language-purs">type Input = { label :: String }

type State = { label :: String }

button :: forall query output m. H.Component query Input output m
button =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval H.defaultEval
    }
  where
  initialState :: Input -&gt; State
  initialState input = input

  render :: forall action. State -&gt; H.ComponentHTML action () m
  render { label } = HH.button [ ] [ HH.text label ]
</code></pre>
<p>We took a few steps to convert our button HTML function into a button component:</p>
<ol>
<li>We converted the argument to our helper function into the <code>Input</code> type for the component. The parent component is responsible for providing this input to our component. We'll learn more about input in the next section.</li>
<li>We moved our HTML into the component's <code>render</code> function. The <code>render</code> function only has access to our component's <code>State</code> type, so in our <code>initialState</code> function we copied our input value into our state so we could render it. Copying input into state is a common pattern in Halogen. Also notice that our <code>render</code> function leaves the action type unspecified (because we don't have any actions) and indicates we have no child components using <code>()</code>.</li>
<li>We used <code>defaultEval</code>, unmodified, as our <code>EvalSpec</code> because this component doesn't need to respond to events arising internally -- it has no actions and uses no lifecycle events, for example.</li>
</ol>
<p>Our parent component is now broken, though! If you've been following along, you'll now see an error:</p>
<pre><code class="language-purs">[1/1 TypesDoNotUnify]

  16    render _ = HH.div_ [ button { label: &quot;Click Me&quot; } ]
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  Could not match type

    Component HTML t2 { label :: String }

  with type

    Function
</code></pre>
<p>Components can't just be rendered by giving the component its input as a function argument. Even though components produce ordinary Halogen HTML they can also communicate with the parent component; for this reason, components need extra information before they can be rendered like an ordinary element.</p>
<p>Conceptually, components occupy a &quot;slot&quot; in your tree of HTML. This slot is a place where the component can produce Halogen HTML until it is removed from the DOM. A component in a slot can be thought of as a dynamic, stateful HTML element. You can freely intermix these dynamic elements with ordinary Halogen HTML elements, but the dynamic elements need more information.</p>
<p>That extra information comes from the <code>slot</code> function and the slot type used in <code>ComponentHTML</code>, which we've so far been leaving as the empty row, <code>()</code>. We'll talk a lot more about rendering components in slots in a moment, but for now let's get things compiling.</p>
<p>We can fix our <code>render</code> function by rendering our component in a slot via the <code>slot</code> function. We'll also update the slot type in our <code>ComponentHTML</code> to include the component our Halogen HTML now must support. This diff demonstrates the differences between rendering an HTML element and rendering a component:</p>
<pre><code class="language-diff">+ import Type.Proxy (Proxy(..))
+
+ type Slots = ( button :: forall query. H.Slot query Void Int )
+
+ _button = Proxy :: Proxy &quot;button&quot;

  parent :: forall query input output m. H.Component query input output m
  parent =
    H.mkComponent
      { initialState: identity
      , render
      , eval: H.mkEval H.defaultEval
      }
    where
-   render :: forall state action. state -&gt; H.ComponentHTML action () m
+   render :: forall state action. state -&gt; H.ComponentHTML action Slots m
    render _ =
-     HH.div_ [ button { label: &quot;Click Me&quot; } ]
+     HH.div_ [ HH.slot_ _button 0 button { label: &quot;Click Me&quot; } ]
</code></pre>
<p>Our parent component is now rendering a child component -- our button component. Rendering a component introduced two big changes:</p>
<ol>
<li>We used the <code>slot_</code> function to render the component, which takes several arguments we haven't explored yet. Two of those arguments are the <code>button</code> component itself and the label it needs as input.</li>
<li>We added a new type called <code>Slots</code>, which is a row containing a label for our button component with a value of type <code>H.Slot</code>, and we used this new type in our <code>ComponentHTML</code> instead of the previous empty row <code>()</code> we've seen so far.</li>
</ol>
<p>The <code>slot</code> and <code>slot_</code> functions and the <code>Slot</code> type let you render a stateful, effectful child component in your Halogen HTML as if it were any other HTML element. But why are there so many arguments and types involved in doing this? Why can't we just call <code>button</code> with its input?</p>
<p>The answer is that Halogen provides two ways for a parent and child component to communicate with one another, and we need to ensure that this communication is type-safe. The <code>slot</code> function allows us to:</p>
<ol>
<li>Decide how to identify a particular component by a label (the type-level string &quot;button&quot;, which we represent at the term level with the proxy <code>Proxy :: Proxy &quot;button&quot;</code>) and a unique identifier (the integer <code>0</code>, in this case) so that we can send it <em>queries</em>. This is an imperative form of communication from the parent to the child.</li>
<li>Render the component (<code>button</code>) and give it its <em>input</em> (<code>{ label: &quot;Click Me&quot; }</code>), which will be re-sent every time the parent component renders in case the input changes over time. This is a declarative form of communication from the parent to the child.</li>
<li>Decide how to handle <em>output messages</em> from the child component. The <code>slot</code> function lets you provide a handler for child outputs, while the <code>slot_</code> function can be used when a child component doesn't have any outputs or you want to ignore them. This is communication from the child to the parent.</li>
</ol>
<p>The <code>slot</code> and <code>slot_</code> functions and the <code>H.Slot</code> type let us manage these three communication mechanisms in a type-safe way. In the rest of this chapter we'll focus on how parent and child components communicate with one another, and along the way we'll explore slots and slot types.</p>
<h2><a class="header" href="#communicating-among-components" id="communicating-among-components">Communicating Among Components</a></h2>
<p>When you move from using one component to using many components you'll soon need some way for them to communicate with one another. In Halogen there are three ways that a parent and child component can communicate directly:</p>
<ol>
<li>The parent component can provide input to the child component. Each time the parent component renders it will send the input again, and then it's up to the child component to decide what to do with the new input.</li>
<li>The child component can emit output messages to the parent, similar to how we've been using subscriptions so far. The child component can notify the parent component when an important event has happened, like a modal closing or a form being submitted, and then the parent can decide what to do.</li>
<li>The parent component can query the child component, either by telling it to do something or by requesting some information from it. The parent component can decide when it needs the child component to do something or give it some information, and then it's up to the child component to handle the query.</li>
</ol>
<p>These three mechanisms give you several ways to communicate between components. Let's briefly explore these three mechanisms, and then we'll see how the <code>slot</code> function and the slot type you define for your component help you use them in a type-safe way.</p>
<h3><a class="header" href="#input-1" id="input-1">Input</a></h3>
<p>Parent components can provide input to child components, which is sent on every render. We've seen this several times already -- the <code>input</code> type is used to produce the child component's initial state. In the example which introduced this chapter our button component received its label from the parent component.</p>
<p>So far we've only used input to produce our initial state. But input doesn't stop once the initial state has been created. The input is sent again on every render, and the child component can handle the new input via the <code>receive</code> function in its eval spec.</p>
<pre><code class="language-purs">receive :: input -&gt; Maybe action
</code></pre>
<p>The <code>receive</code> function in the eval spec should remind you of <code>initialize</code> and <code>finalize</code>, which let you choose an action to evaluate when the component is created and destroyed. In the same way, the <code>receive</code> function lets you choose an action to evaluate when the parent component sends new input.</p>
<p>By default Halogen's <code>defaultSpec</code> doesn't provide an action to be evaluated when new input is received. If your child component doesn't need to do anything after it receives its initial value then you can leave this as-is. For example, once our button received its label and copied it into state there was no need to continue listening to the input in case it changed over time.</p>
<p>The ability to receive new input every time the parent renders is a powerful feature. It means parent components can declaratively provide values to child components. There are other ways for a parent component to communicate with a child component, but the declarative nature of input makes it the best choice in most circumstances.</p>
<p>Let's make this concrete by revisiting our example from the introduction. In this version our button is unchanged -- it receives its label as input and uses it to set its initial state -- but our parent component has changed. Our parent component now starts a timer when it initializes, increments a count every second, and uses the count in state as the label for the button.</p>
<p>In short, our button's input will be re-sent every second. Try pasting this into <a href="https://try.purescript.org">Try PureScript</a> to see what happens -- does our button's label update every second?</p>
<pre><code class="language-purs">module Main where

import Prelude

import Control.Monad.Rec.Class (forever)
import Data.Maybe (Maybe(..))
import Effect (Effect)
import Effect.Aff (Milliseconds(..))
import Effect.Aff as Aff
import Effect.Aff.Class (class MonadAff)
import Halogen as H
import Halogen.Aff (awaitBody, runHalogenAff)
import Halogen.HTML as HH
import Halogen.Subscription as HS
import Halogen.VDom.Driver (runUI)
import Type.Proxy (Proxy(..))

main :: Effect Unit
main = runHalogenAff do
  body &lt;- awaitBody
  runUI parent unit body

type Slots = ( button :: forall q. H.Slot q Void Unit )

_button = Proxy :: Proxy &quot;button&quot;

type ParentState = { count :: Int }

data ParentAction = Initialize | Increment

parent :: forall query input output m. MonadAff m =&gt; H.Component query input output m
parent =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval $ H.defaultEval
        { handleAction = handleAction
        , initialize = Just Initialize
        }
    }
  where
  initialState :: input -&gt; ParentState
  initialState _ = { count: 0 }

  render :: ParentState -&gt; H.ComponentHTML ParentAction Slots m
  render { count } =
    HH.div_ [ HH.slot_ _button unit button { label: show count } ]

  handleAction :: ParentAction -&gt; H.HalogenM ParentState ParentAction Slots output m Unit
  handleAction = case _ of
    Initialize -&gt; do
      { emitter, listener } &lt;- H.liftEffect HS.create
      void $ H.subscribe emitter
      void
        $ H.liftAff
        $ Aff.forkAff
        $ forever do
            Aff.delay $ Milliseconds 1000.0
            H.liftEffect $ HS.notify listener Increment
    Increment -&gt; H.modify_ \st -&gt; st { count = st.count + 1 }

-- Now we turn to our child component, the button.

type ButtonInput = { label :: String }

type ButtonState = { label :: String }

button :: forall query output m. H.Component query ButtonInput output m
button =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval H.defaultEval
    }
  where
  initialState :: ButtonInput -&gt; ButtonState
  initialState { label } = { label }

  render :: forall action. ButtonState -&gt; H.ComponentHTML action () m
  render { label } = HH.button_ [ HH.text label ]
</code></pre>
<p>If you load this into Try PureScript you'll see that our button...never changes! Even though the parent component is sending it new input every second (every time the parent re-renders) our child component is never receiving it. It's not enough to accept input; we also need to explicitly decide what to do each time it is received.</p>
<p>Try replacing the button code with this revised code to see the difference:</p>
<pre><code class="language-purs">data ButtonAction = Receive ButtonInput

type ButtonInput = { label :: String }

type ButtonState = { label :: String }

button :: forall query output m. H.Component query ButtonInput output m
button =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval $ H.defaultEval
        { handleAction = handleAction
        , receive = Just &lt;&lt;&lt; Receive
        }
    }
  where
  initialState :: ButtonInput -&gt; ButtonState
  initialState { label } = { label }

  render :: ButtonState -&gt; H.ComponentHTML ButtonAction () m
  render { label } = HH.button_ [ HH.text label ]

  handleAction :: ButtonAction -&gt; H.HalogenM ButtonState ButtonAction () output m Unit
  handleAction = case _ of
    -- When we receive new input we update our `label` field in state.
    Receive input -&gt;
      H.modify_ _ { label = input.label }
</code></pre>
<p>We made several changes in the new version to ensure we stayed up-to-date with input from the parent component:</p>
<ol>
<li>We added a new action, <code>Receive</code>, a constructor that accepts the <code>Input</code> type as its argument. We then handled this action in our <code>handleAction</code> function by updating our state when new input is received.</li>
<li>We added a new field to our eval spec, <code>receive</code>, which holds a function that will be called every time new input is received. Our function returns our <code>Receive</code> action so it can be evaluated.</li>
</ol>
<p>This change is sufficient to subscribe our child component to new input from the parent component. You should now see that our button's label updates every second. As an exercise, you can replace our <code>receive</code> function with <code>const Nothing</code> to see the how the input is ignored once again.</p>
<h3><a class="header" href="#output-messages" id="output-messages">Output Messages</a></h3>
<p>Sometimes an event happens in a child component that it shouldn't handle itself.</p>
<p>For example, let's say we're writing a modal component, and we need to evaluate some code when a user clicks to close the modal. To keep this modal flexible we'd like for the parent component to decide what should happen when the modal is closed.</p>
<p>In Halogen we'd handle this situation by designing the modal (the child component) to raise an <strong>output message</strong> to the parent component. The parent component can then handle the message like any other action in its <code>handleAction</code> function. Conceptually, it's as though the child component is a subscription that the parent component automatically subscribes to.</p>
<p>Concretely, our modal could raise a <code>Closed</code> output to the parent component. The parent could then change its state to indicate the modal should no longer display, and on the next render the modal is removed from the DOM.</p>
<p>As a tiny example, let's consider how we'd design a button that lets the parent component decide what to do when it is clicked:</p>
<pre><code class="language-purs">module Button where

-- This component can notify parent components of one event, `Clicked`
data Output = Clicked

-- This component can handle one internal event, `Click`
data Action = Click

-- Our output type shows up in our `Component` type
button :: forall query input m. H.Component query input Output m
button =
  H.mkComponent
    { initialState: identity
    , render
    , eval: H.mkEval $ H.defaultEval { handleAction = handleAction }
    }
  where
  render _ =
    HH.button
      [ HE.onClick \_ -&gt; Click ]
      [ HH.text &quot;Click me&quot; ]

  -- Our output type also shows up in our `HalogenM` type, because this is
  -- where we can emit these output messages.
  handleAction :: forall state. Action -&gt; H.HalogenM state Action () Output m Unit
  handleAction = case _ of
    -- When the button is clicked we notify the parent component that the
    -- `Clicked` event has happened by emitting it with `H.raise`.
    Click -&gt;
      H.raise Clicked
</code></pre>
<p>We took a few steps to implement this output message.</p>
<ol>
<li>We added an <code>Output</code> type which describes what output messages our component can emit. We used the type in our <code>Component</code> type because it's part of the component's public interface and our <code>HalogenM</code> type because this is where we can actually emit the output message.</li>
<li>We added an <code>Action</code> type with a <code>Click</code> constructor to handle the click event in our Halogen HTML</li>
<li>We handled the <code>Click</code> action in our <code>handleAction</code> by <em>raising</em> an output message to the parent component. You can emit output messages with the <code>H.raise</code> function.</li>
</ol>
<p>We now know how a component can emit output messages. Now, let's see how to handle output messages from a child component. There are three things to keep in mind:</p>
<ol>
<li>When you render a child component you will need to add it to your slots type, which is then used in your <code>ComponentHTML</code> and <code>HalogenM</code> types. The type you add will include the child component's output message type, which allows the compiler to verify your handler.</li>
<li>When you render a child component with the <code>slot</code> function you can provide an action that should be evaluated when new output arises. This is similar to how lifecycle functions like <code>initialize</code> accept an action to evaluate when the component initializes.</li>
<li>Then, you'll need to add a case to your <code>handleAction</code> for the action you added to handle the child component's output.</li>
</ol>
<p>Let's start writing our parent component by writing a slot type:</p>
<pre><code class="language-purs">module Parent where

import Button as Button

type Slots = ( button :: forall query. H.Slot query Button.Output Int )

-- We can refer to the `button` label using a symbol proxy, which is a
-- way to refer to a type-level string like `button` at the value level.
-- We define this for convenience, so we can use _button to refer to its
-- label in the slot type rather than write `Proxy` over and over.
_button = Proxy :: Proxy &quot;button&quot;
</code></pre>
<p>Our slot type is a row, where each label designates a particular <em>type</em> of child component we support, in each case using the type <code>H.Slot</code>:</p>
<pre><code class="language-purs">H.Slot query output id
</code></pre>
<p>This type records the queries that can be sent to this type of component, the output messages that we can handle from the component, and a type we can use to uniquely identify an individual component.</p>
<p>Consider, for example, that we could render 10 of these button components -- how would you know which one to send a query to? That's where the slot id comes into play. We'll learn more about that when we discuss queries.</p>
<p>Our parent component's row type makes it clear that we can support one type of child component, which we can reference with the symbol <code>button</code> and an identifier of type <code>Int</code>. We can't send queries to this component because the type variable was left open. But it can send us outputs of type <code>Button.Output</code>.</p>
<p>Next, we need to provide an action for handling these outputs:</p>
<pre><code class="language-purs">data Action = HandleButton Button.Output
</code></pre>
<p>When this action occurs in our component, we can unwrap it to get the <code>Button.Output</code> value and use that to decide what code to evaluate. Now that we have our slot and action types handled, let's write our parent component:</p>
<pre><code class="language-purs">parent :: forall query input output m. H.Component query input output m
parent =
  H.mkComponent
    { initialState: identity
    , render
    , eval: H.mkEval $ H.defaultEval { handleAction = handleAction }
    }
  where
  render :: forall state. state -&gt; H.ComponentHTML Action Slots m
  render _ =
    HH.div_
      [ HH.slot _button 0 button unit HandleButton ]

  handleAction :: forall state. Action -&gt; H.HalogenM state Action Slots output m Unit
  handleAction = case _ of
    HandleButton output -&gt;
      case output of
        Button.Clicked -&gt; do
          ...
</code></pre>
<p>You'll notice that our <code>Slots</code> type has now been used in both the <code>ComponentHTML</code> type and the <code>HalogenM</code> type. Also, this component is now notified any time the <code>Button.Clicked</code> event happens in the child component, which lets the parent component evaluate whatever code it wants in response.</p>
<p>And that's it! You now know how to raise output messages from a child component to a parent component and how to then handle those messages in the parent component. This is the primary way a child component can communicate with a parent component. Now let's see how a parent component can send information to a child component.</p>
<h3><a class="header" href="#queries" id="queries">Queries</a></h3>
<p>Queries represent commands or requests that a parent component can send to a child component. They're similar to actions and are handled with a <code>handleQuery</code> function similar to the <code>handleAction</code> function. But they arise from <em>outside</em> the component, instead of internally within the component as actions are, which means they are part of the public interface of a component.</p>
<p>Queries are most useful when a parent component needs to control when an event occurs instead of a child component. For example:</p>
<ul>
<li>A parent component can <em>tell</em> a form to submit, rather than wait for a user to click a submit button.</li>
<li>A parent component can <em>request</em> the current selections from an autocomplete, rather than wait for an output message from the child component when a selection is made.</li>
</ul>
<p>Queries are a way for parent components to imperatively control a child component. As introduced in our two examples, there are two common styles of query: a tell-style query for when a parent component commands a child component to do something, and a request-style query for when a parent component wants information from a child component.</p>
<p>The parent component can send a query, but the child component defines the query and also handles the query. That makes queries similar conceptually to actions: just like how you define an <code>Action</code> type and handle actions for your component with <code>handleAction</code>, you define a <code>Query</code> type and a <code>handleQuery</code> function for queries.</p>
<p>Here's a brief example of a query type that includes a tell-style and request-style query:</p>
<pre><code class="language-purs">data Query a
  = Tell a
  | Request (Boolean -&gt; a)
</code></pre>
<p>We can interpret this query as meaning &quot;A parent component can tell this component to do something with the <code>tell</code> function and it can request a <code>Boolean</code> from this component with the <code>request</code> function.&quot; When you implement a query type, remember that the <code>a</code> type parameter should be present in every constructor. It should be the final argument for tell-style queries and be the result of a function type for request-style queries.</p>
<p>Queries are handled with a <code>handleQuery</code> function in your eval spec, just like how actions are handled with a <code>handleAction</code> function. Let's write a <code>handleQuery</code> function for our custom data type, assuming some state, action, and output types have already been defined:</p>
<pre><code class="language-purs">handleQuery :: forall a m. Query a -&gt; H.HalogenM State Action () Output m (Maybe a)
handleQuery = case _ of
  Tell a -&gt;
    -- ... do something, then return the `a` we received
    pure (Just a)

  Request reply -&gt;
    -- ... do something, then provide the requested `Boolean` to the `reply`
    -- function to produce the `a` we need to return
    pure (Just (reply true))
</code></pre>
<p>The <code>handleQuery</code> function takes a query of type <code>Query a</code> and produces some <code>HalogenM</code> code that returns <code>Maybe a</code>. This is why each constructor of our query type needs to contain an <code>a</code>: we need to return it in <code>handleQuery</code>.</p>
<p>When we receive a tell-style query we can just wrap the <code>a</code> we received in <code>Just</code> to return it, as we did to handle the <code>Tell a</code> case in <code>handleQuery</code>.</p>
<p>When we receive a request-style query, though, we have to do a little more work. Instead of receiving an <code>a</code> value we can return, we receive a function that will give us an <code>a</code> that we can then return. For example, in our <code>Request (Boolean -&gt; a)</code> case, we receive a function that will give us an <code>a</code> when we apply it to a <code>Boolean</code>. By convention this function is called <code>reply</code> when you pattern match on a request-style query. In <code>handleQuery</code> we gave this function <code>true</code> to get an <code>a</code>, then wrapped the <code>a</code> in <code>Just</code> to return it.</p>
<p>Request-style queries may look strange at first. But the style allows our query type to return <em>many</em> types of values instead of only one type of value. Here are a few different request types that return different things:</p>
<pre><code class="language-purs">data Requests a
  = GetInt (Int -&gt; a)
  | GetRecord ({ a :: Int, b :: String } -&gt; a)
  | GetString (String -&gt; a)
  | ...
</code></pre>
<p>A parent component can use <code>GetInt</code> to retrieve an <code>Int</code> from our component, <code>GetString</code> to retrieve a <code>String</code> from our component, and so on. You can consider <code>a</code> the type returned by the query type, and request-style queries a way to let <code>a</code> be many different possible types. In a moment we'll see how to do this from a parent component.</p>
<p>Let's see another tiny example that demonstrates how to define and handle queries in a component.</p>
<pre><code class="language-purs">-- This component can be told to increment or can answer requests for
-- the current count
data Query a
  = Increment a
  | GetCount (Int -&gt; a)

type State = { count :: Int }

-- Our query type shows up in our `Component` type
counter :: forall input output m. H.Component Query input output m
counter =
  H.mkComponent
    { initialState: \_ -&gt; { count: 0 }
    , render
    , eval: H.mkEval $ H.defaultEval { handleQuery = handleQuery }
    }
  where
  render { count } =
    HH.div_
      [ HH.text $ show count ]

  -- We write a function to handle queries when they arise.
  handleQuery :: forall action a. Query a -&gt; H.HalogenM State action () output m (Maybe a)
  handleQuery = case _ of
    -- When we receive the `Increment` query we'll increment our state.
    Increment a -&gt; do
      H.modify_ \state -&gt; state { count = state.count + 1 }
      pure (Just a)

    -- When we receive the `GetCount` query we'll respond with the state.
    GetCount reply -&gt; do
      { count } &lt;- H.get
      pure (Just (reply count))
</code></pre>
<p>In this example we've defined a counter that lets the parent <em>tell</em> it to increment or <em>request</em> its current count. To do this, we:</p>
<ol>
<li>Implemented a query type that includes a tell-style query, <code>Increment a</code>, and a request-style query, <code>GetCount (Int -&gt; a)</code>. We added this query type to our component's public interface, <code>Component</code>.</li>
<li>Implemented a query handler, <code>handleQuery</code>, that runs code when these queries arise. We'll add this to our <code>eval</code>.</li>
</ol>
<p>We now know how to define queries and evaluate them in a child component. Now, let's see how to <em>send</em> a query to a child component from a parent component. As usual, we can start by defining our parent component's slot type:</p>
<pre><code class="language-purs">module Parent where

type Slots = ( counter :: H.Slot Counter.Query Void Int )

_counter = Proxy :: Proxy &quot;counter&quot;
</code></pre>
<p>Our slot type records the counter component with its query type and leaves its output message type as <code>Void</code> to indicate there are none.</p>
<p>When our parent component initializes, we'll fetch the count from the child component, then increment it, and then get the count again so we can see that it has increased. To do that, we'll need an action to run on initialize:</p>
<pre><code class="language-purs">data Action = Initialize
</code></pre>
<p>Now, we can move on to our component definition.</p>
<pre><code class="language-purs">parent :: forall query input output m. H.Component query input output m
parent =
  H.mkComponent
    { initialState: identity
    , render
    , eval: H.mkEval $ H.defaultEval
        { handleAction = handleAction
        , initialize = Just Initialize
        }
    }
  where
  render :: forall state. state -&gt; H.ComponentHTML Action Slots m
  render _ =
    HH.div_
      [ HH.slot_ _counter unit counter unit ]

  handleAction :: forall state. Action -&gt; H.HalogenM state Action Slots output m Unit
  handleAction = case _ of
    Initialize -&gt;
      -- startCount :: Maybe Int
      startCount &lt;- H.request _counter unit Counter.GetCount
      -- _ :: Maybe Unit
      H.tell _counter unit Counter.Increment
      -- endCount :: Maybe Int
      endCount &lt;- H.request _counter unit Counter.GetCount

      when (startCount /= endCount) do
        -- ... do something
</code></pre>
<p>There are several things to notice here.</p>
<ol>
<li>We used the proxy for the counter's label in the slot type, <code>_counter</code>, along with its identifier, <code>unit</code>, both to render the component with the <code>slot</code> function and also to send queries to the component with the <code>tell</code> and <code>request</code> functions. The label and identifier are always used to work with a particular child component.</li>
<li>We used the <code>H.tell</code> function to send the tell-style query <code>Increment</code>, and we used the <code>H.request</code> function to send the request-style query <code>GetCount</code>. The <code>GetCount</code> query had a reply function of type <code>(Int -&gt; a)</code>, so you'll notice that when we used it we received a <code>Maybe Int</code> in return.</li>
</ol>
<p>The <code>tell</code> and <code>request</code> functions take a label, a slot identifier, and a query to send. The <code>tell</code> function doesn't return anything, but the <code>request</code> function returns a response from the child wrapped in <code>Maybe</code>, where <code>Nothing</code> signifies that the query failed (either the child component returned <code>Nothing</code>, or no component exists at the label and slot identifier you provided). There are also <code>tellAll</code> and <code>requestAll</code> functions that send the same query to <em>all</em> components at a given label.</p>
<p>Many people find queries to be the most confusing part of the Halogen library. Luckily, queries aren't used nearly so much as the other Halogen features we've learned about in this guide, and if you get stuck you can always return to this section of the guide as a reference.</p>
<h2><a class="header" href="#component-slots" id="component-slots">Component Slots</a></h2>
<p>We've learned a lot about how components communicate with one another. Before we move on to our final example let's recap what we've learned about slots along the way.</p>
<p>A component needs to know what types of child component its supports so that it's able to communicate with them. It needs to know what queries it can send to them and what output messages it can receive from them. It also needs to know how to identify which particular component to send a query to.</p>
<p>The <code>H.Slot</code> type captures the queries, outputs, and unique identifier for a particular type of child component the parent component can support. You can combine many slots together into a <em>row</em> of slots, where each label is used for a particular type of component. Here's how you could read the type definitions for a few different slots:</p>
<pre><code class="language-purs">type Slots = ()
</code></pre>
<p>This means the component supports no child components.</p>
<pre><code class="language-purs">type Slots = ( button :: forall query. H.Slot query Void Unit )
</code></pre>
<p>This means the component supports one type of child component, identified by the symbol <code>button</code>. You can't send queries to it (because <code>q</code> is an open type variable) and it doesn't emit any output messages (usually represented with <code>Void</code> so you can use <code>absurd</code> as the handler). You can have at most one of this component because only one value, <code>unit</code>, inhabits the <code>Unit</code> type.</p>
<pre><code class="language-purs">type Slots = ( button :: forall query. H.Slot query Button.Output Int )
</code></pre>
<p>This type is quite similar to previous one. The difference is that the child component can raise output messages of type <code>Button.Output</code>, and you can have as many of this component as there are integers.</p>
<pre><code class="language-purs">type Slots =
  ( button :: H.Slot Button.Query Void Int
  , modal :: H.Slot Modal.Query Modal.Output Unit
  )
</code></pre>
<p>This slot type means the component supports two types of child component, identified by the labels <code>button</code> and <code>modal</code>. You can send queries of type <code>Button.Query</code> to the button component, and you won't receive any output messages from it. You can send queries of type <code>Modal.Query</code> to and receive messages of type <code>Modal.Output</code> from the modal component. You can have as many of the button component as there are integers, but at most one modal component.</p>
<p>A common pattern in Halogen apps is for a component to export its own slot type, because it already knows its query and messages types, without exporting the type that identifies this particular component because that's the parent's responsibility.</p>
<p>For example, if the button and modal component modules exported their own slot types, like this:</p>
<pre><code class="language-purs">module Button where

type Slot id = H.Slot Query Void id

module Modal where

type Slot id = H.Slot Query Output id
</code></pre>
<p>Then our last slot type example would become this simpler type:</p>
<pre><code class="language-purs">type Slots =
  ( button :: Button.Slot Int
  , modal :: Modal.Slot Unit
  )
</code></pre>
<p>This has the advantage of being more concise and easier to keep up-to-date over time, as if there are changes to the slot type they can happen in the source module instead of everywhere the slot type is used.</p>
<h2><a class="header" href="#full-example" id="full-example">Full Example</a></h2>
<p>To wrap up, we've written an example of a parent and child component using all the communication mechanisms we've discussed in this chapter. The example is annotated with how we'd interpret the most important lines of code -- what we'd glean by skimming through these component definitions in our own codebases.</p>
<p>As usual, we suggest pasting this code into <a href="https://try.purescript.org">Try PureScript</a> so you can explore it interactively.</p>
<pre><code class="language-purs">module Main where

import Prelude

import Data.Maybe (Maybe(..))
import Effect (Effect)
import Effect.Class (class MonadEffect)
import Effect.Class.Console (logShow)
import Halogen as H
import Halogen.Aff as HA
import Halogen.HTML as HH
import Halogen.HTML.Events as HE
import Halogen.VDom.Driver (runUI)
import Type.Proxy (Proxy(..))

main :: Effect Unit
main = HA.runHalogenAff do
  body &lt;- HA.awaitBody
  runUI parent unit body

-- The parent component supports one type of child component, which uses the
-- `ButtonSlot` slot type. You can have as many of this type of child component
-- as there are integers.
type Slots = ( button :: ButtonSlot Int )

-- The parent component can only evaluate one action: handling output messages
-- from the button component, of type `ButtonOutput`.
data ParentAction = HandleButton ButtonOutput

-- The parent component maintains in local state the number of times all its
-- child component buttons have been clicked.
type ParentState = { clicked :: Int }

-- The parent component uses no query, input, or output types of its own. It can
-- use any monad so long as that monad can run `Effect` functions.
parent :: forall query input output m. MonadEffect m =&gt; H.Component query input output m
parent =
  H.mkComponent
    { initialState
    , render
      -- The only internal event this component can handle are actions as
      -- defined in the `ParentAction` type.
    , eval: H.mkEval $ H.defaultEval { handleAction = handleAction }
    }
  where
  initialState :: input -&gt; ParentState
  initialState _ = { clicked: 0 }

  -- We render three buttons, handling their output messages with the `HandleButton`
  -- action. When our state changes this render function will run again, each time
  -- sending new input (which contains a new label for the child button component
  -- to use.)
  render :: ParentState -&gt; H.ComponentHTML ParentAction Slots m
  render { clicked } = do
    let clicks = show clicked
    HH.div_
      [ -- We render our first button with the slot id 0
        HH.slot _button 0 button { label: clicks &lt;&gt; &quot; Enabled&quot; } HandleButton
        -- We render our second button with the slot id 1
      , HH.slot _button 1 button { label: clicks &lt;&gt; &quot; Power&quot; } HandleButton
        -- We render our third button with the slot id 2
      , HH.slot _button 2 button { label: clicks &lt;&gt; &quot; Switch&quot; } HandleButton
      ]

  handleAction :: ParentAction -&gt; H.HalogenM ParentState ParentAction Slots output m Unit
  handleAction = case _ of
    -- We handle one action, `HandleButton`, which itself handles the output messages
    -- of our button component.
    HandleButton output -&gt; case output of
      -- There is only one output message, `Clicked`.
      Clicked -&gt; do
        -- When the `Clicked` message arises we will increment our clicked count
        -- in state, then send a query to the first button to tell it to be `true`,
        -- then send a query to all the child components requesting their current
        -- enabled state, which we log to the console.
        H.modify_ \state -&gt; state { clicked = state.clicked + 1 }
        H.tell _button 0 (SetEnabled true)
        on &lt;- H.requestAll _button GetEnabled
        logShow on

-- We now move on to the child component, a component called `button`.

-- This component can accept queries of type `ButtonQuery` and send output
-- messages of type `ButtonOutput`. This slot type is exported so that other
-- components can use it when constructing their row of slots.
type ButtonSlot = H.Slot ButtonQuery ButtonOutput

-- We think our button will have the label &quot;button&quot; in the row where it's used,
-- so we're exporting a symbol proxy for convenience.
_button = Proxy :: Proxy &quot;button&quot;

-- This component accepts two queries. The first is a request-style query that
-- lets a parent component request a `Boolean` value from us. The second is a
-- tell-style query that lets a parent component send a `Boolean` value to us.
data ButtonQuery a
  = GetEnabled (Boolean -&gt; a)
  | SetEnabled Boolean a

-- This component can notify parent components of one event, `Clicked`
data ButtonOutput
  = Clicked

-- This component can handle two internal actions. It can evaluate a `Click`
-- action and it can receive new input when its parent re-renders.
data ButtonAction
  = Click
  | Receive ButtonInput

-- This component accepts a label as input
type ButtonInput = { label :: String }

-- This component stores a label and an enabled flag in state
type ButtonState = { label :: String, enabled :: Boolean }

-- This component supports queries of type `ButtonQuery`, requires input of
-- type `ButtonInput`, and can send outputs of type `ButtonOutput`. It doesn't
-- perform any effects, which we can tell because the `m` type parameter has
-- no constraints.
button :: forall m. H.Component ButtonQuery ButtonInput ButtonOutput m
button =
  H.mkComponent
    { initialState
    , render
      -- This component can handle internal actions, handle queries sent by a
      -- parent component, and update when it receives new input.
    , eval: H.mkEval $ H.defaultEval
        { handleAction = handleAction
        , handleQuery = handleQuery
        , receive = Just &lt;&lt;&lt; Receive
        }
    }
  where
  initialState :: ButtonInput -&gt; ButtonState
  initialState { label } = { label, enabled: false }

  -- This component has no child components. When the rendered button is clicked
  -- we will evaluate the `Click` action.
  render :: ButtonState -&gt; H.ComponentHTML ButtonAction () m
  render { label, enabled } =
    HH.button
      [ HE.onClick \_ -&gt; Click ]
      [ HH.text $ label &lt;&gt; &quot; (&quot; &lt;&gt; (if enabled then &quot;on&quot; else &quot;off&quot;) &lt;&gt; &quot;)&quot; ]

  handleAction
    :: ButtonAction
    -&gt; H.HalogenM ButtonState ButtonAction () ButtonOutput m Unit
  handleAction = case _ of
    -- When we receive new input we update our `label` field in state.
    Receive input -&gt;
      H.modify_ _ { label = input.label }

    -- When the button is clicked we update our `enabled` field in state, and
    -- we notify our parent component that the `Clicked` event happened.
    Click -&gt; do
      H.modify_ \state -&gt; state { enabled = not state.enabled }
      H.raise Clicked

  handleQuery
    :: forall a
     . ButtonQuery a
    -&gt; H.HalogenM ButtonState ButtonAction () ButtonOutput m (Maybe a)
  handleQuery = case _ of
    -- When we receive a the tell-style `SetEnabled` query with a boolean, we
    -- set that value in state.
    SetEnabled value next -&gt; do
      H.modify_ _ { enabled = value }
      pure (Just next)

    -- When we receive a the request-style `GetEnabled` query, which requires
    -- a boolean result, we get a boolean from our state and reply with it.
    GetEnabled reply -&gt; do
      enabled &lt;- H.gets _.enabled
      pure (Just (reply enabled))
</code></pre>
<p>In the next chapter we'll learn more about running Halogen applications.</p>
<h1><a class="header" href="#running-an-application" id="running-an-application">Running an Application</a></h1>
<p>Over the course of this guide we've seen the standard way to run a Halogen application several times. In this chapter, we'll learn what is actually going on when we run a Halogen application and how to control a running app from the outside.</p>
<h2><a class="header" href="#using-runui-and-awaitbody" id="using-runui-and-awaitbody">Using <code>runUI</code> and <code>awaitBody</code></a></h2>
<p>PureScript applications use the <code>main</code> function in their <code>Main</code> module as their entrypoint. Here's a standard <code>main</code> function for Halogen apps:</p>
<pre><code class="language-purs">module Main where

import Prelude

import Effect (Effect)
import Halogen.Aff as HA
import Halogen.VDom.Driver (runUI)

main :: Effect Unit
main = HA.runHalogenAff do
  body &lt;- HA.awaitBody
  runUI component unit body

-- Assuming you have defined a root component for your application
component :: forall query input output m. H.Component query input output m
component = ...
</code></pre>
<p>The most important function used in <code>main</code> is the <code>runUI</code> function. Provide <code>runUI</code> with your root component, the root component's input value, and a reference to a DOM element, and it will provide your application to the Halogen virtual DOM. The virtual DOM will then render your application at that element and maintain it there for as long as your app is running.</p>
<pre><code class="language-purs">runUI
  :: forall query input output
   . Component query input output Aff
  -&gt; input
  -&gt; DOM.HTMLElement
  -&gt; Aff (HalogenIO query output Aff)
</code></pre>
<p>As you can see, the <code>runUI</code> function requires that your Halogen application can ultimately be run in the <code>Aff</code> monad. In this guide we used constraints like <code>MonadEffect</code> and <code>MonadAff</code>, which <code>Aff</code> satisfies, so we're in the clear.</p>
<blockquote>
<p>If you chose to use another monad for your application then you'll need to hoist it to run in <code>Aff</code> before you provide your application to <code>runUI</code>. The <a href="https://github.com/thomashoneyman/purescript-halogen-realworld">Real World Halogen</a> uses a custom <code>AppM</code> monad that serves as a good example of how to do this.</p>
</blockquote>
<p>In addition to <code>runUI</code> we used two other helper functions. First, we used <code>awaitBody</code> to wait for the page to load and then acquire a reference to the <code>&lt;body&gt;</code> tag as the root HTML element for the application to control. Second, we used <code>runHalogenAff</code> to launch asynchronous effects (our <code>Aff</code> code containing <code>awaitBody</code> and <code>runUI</code>) from within <code>Effect</code>. This is necessary because <code>awaitBody</code>, <code>runUI</code>, and our applications run in the <code>Aff</code> monad, but PureScript <code>main</code> functions must be in <code>Effect</code>.</p>
<p>The <code>main</code> function we've used here is the standard way to run a Halogen application that is the only thing running on the page. Sometimes, though, you may use Halogen to take over just one part of the page, or you may be running multiple Halogen apps. In these cases, you'll probably reach for a pair of different helper functions:</p>
<ol>
<li><code>awaitLoad</code> blocks until the document has loaded so that you can safely retrieve references to HTML elements on the page</li>
<li><code>selectElement</code> can be used to target a particular element on the page to embed the app within</li>
</ol>
<h2><a class="header" href="#using-halogenio" id="using-halogenio">Using <code>HalogenIO</code></a></h2>
<p>When you run your Halogen application with <code>runUI</code> you receive a record of functions with the type <code>HalogenIO</code>. These functions can be used to control your root component from outside the application. Conceptually, they're like a makeshift parent component for your application.</p>
<pre><code class="language-purs">type HalogenIO query output m =
  { query :: forall a. query a -&gt; m (Maybe a)
  , messages :: Event output
  , dispose :: m Unit
  }
</code></pre>
<ol>
<li>The <code>query</code> function is like the <code>H.query</code> function which underpins <code>tell</code> and <code>request</code>. This allows you to send queries to the root component of your application from outside the application.</li>
<li>The <code>messages</code> event can be used to subscribe to a stream of output messages from the component -- it's like the handler we provided to the <code>slot</code> function, except rather than evaluate an action here we can perform some effect instead.</li>
<li>The <code>dispose</code> function can be used to halt and clean up the Halogen application. This will kill any forked threads, close all subscriptions, and so on.</li>
</ol>
<p>You can't use <code>tell</code> and <code>request</code> at the root of your application, but you can use the <code>mkTell</code> and <code>mkRequest</code> functions (as seen in the example below) for a similar effect.</p>
<p>A common pattern in Halogen applications is to use a <code>Route</code> component as the root of the application, and use the <code>query</code> function from <code>HalogenIO</code> to trigger route changes in the application when the URL changes. You can see a full example of doing this in the <a href="https://github.com/thomashoneyman/purescript-halogen-realworld/blob/master/src/Main.purs">Real World Halogen <code>Main.purs</code> file</a>.</p>
<h2><a class="header" href="#full-example-controlling-a-button-with-halogenio" id="full-example-controlling-a-button-with-halogenio">Full Example: Controlling a Button With <code>HalogenIO</code></a></h2>
<p>You can paste this example into <a href="https://try.purescript.org">Try PureScript</a> to explore using <code>HalogenIO</code> to control the root component of an application.</p>
<pre><code class="language-purs">module Example.Driver.IO.Main where

import Prelude

import Data.Maybe (Maybe(..))
import Effect (Effect)
import Effect.Console (log)
import Halogen (liftEffect)
import Halogen as H
import Halogen.HTML as HH
import Halogen.Aff as HA
import Halogen.HTML.Events as HE
import Halogen.HTML.Properties as HP
import Halogen.Subscription as HS
import Halogen.VDom.Driver (runUI)

main :: Effect Unit
main = HA.runHalogenAff do
  body &lt;- HA.awaitBody
  io &lt;- runUI component unit body

  _ &lt;- liftEffect $ HS.subscribe io.messages \(Toggled newState) -&gt; do
    liftEffect $ log $ &quot;Button was internally toggled to: &quot; &lt;&gt; show newState
    pure Nothing

  state0 &lt;- io.query $ H.mkRequest IsOn
  liftEffect $ log $ &quot;The button state is currently: &quot; &lt;&gt; show state0

  void $ io.query $ H.mkTell (SetState true)

  state1 &lt;- io.query $ H.mkRequest IsOn
  liftEffect $ log $ &quot;The button state is now: &quot; &lt;&gt; show state1

-- Child component implementation

type Slot = H.Slot Query Message

data Query a
  = IsOn (Boolean -&gt; a)
  | SetState Boolean a

data Message = Toggled Boolean

data Action = Toggle

type State = { enabled :: Boolean }

component :: forall i m. H.Component Query i Message m
component =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval $ H.defaultEval
        { handleAction = handleAction
        , handleQuery = handleQuery
        }
    }

initialState :: forall i. i -&gt; State
initialState _ = { enabled: false }

render :: forall m. State -&gt; H.ComponentHTML Action () m
render state =
  let
    label = if state.enabled then &quot;On&quot; else &quot;Off&quot;
  in
    HH.button
      [ HP.title label
      , HE.onClick \_ -&gt; Toggle
      ]
      [ HH.text label ]

handleAction :: forall m. Action -&gt; H.HalogenM State Action () Message m Unit
handleAction = case _ of
  Toggle -&gt; do
    newState &lt;- H.modify \st -&gt; st { enabled = not st.enabled }
    H.raise (Toggled newState.enabled)

handleQuery :: forall m a. Query a -&gt; H.HalogenM State Action () Message m (Maybe a)
handleQuery = case _ of
  IsOn k -&gt; do
    enabled &lt;- H.gets _.enabled
    pure (Just (k enabled))
  SetState enabled a -&gt; do
    H.modify_ (_ { enabled = enabled })
    pure (Just a)
</code></pre>
<h1><a class="header" href="#next-steps" id="next-steps">Next Steps</a></h1>
<p>This guide has demonstrated the basic building blocks for Halogen applications. We learned how Halogen provides a type-safe, declarative way to build complex apps out of reusable pieces called components. We learned how write functions that produce Halogen HTML, how to write individual components, and how to render components within other components. We also learned how components can communicate with each other and how to run a full Halogen application.</p>
<p>You now know how Halogen works, but you may not yet feel comfortable building a real application with the library yet. That's perfectly normal! There are more resources to help you continue learning about Halogen.</p>
<ol>
<li>To go more in-depth on concepts you learned in this guide, explore the <a href="guide/../concepts-reference">Concepts Reference</a>.</li>
<li>To learn Halogen in a slower-paced, bottom-up way, try reviewing Jordan Martinez's <a href="https://github.com/JordanMartinez/learn-halogen">Learn Halogen</a> repository.</li>
<li>To learn how to build real world applications in Halogen, review the Real World Halogen <a href="https://thomashoneyman.com/guides/real-world-halogen/">handbook</a> and <a href="https://github.com/thomashoneyman/purescript-halogen-realworld/">example application</a>.</li>
</ol>
<h1><a class="header" href="#halogen-concepts-reference" id="halogen-concepts-reference">Halogen Concepts Reference</a></h1>
<p>Halogen is a declarative, component-based UI library for PureScript that emphasizes type safety. This concepts reference is a glossary of the concepts used in Halogen, along with their technical motivation.</p>
<p>This reference is still in progress. Check back later to see the finished product! For now, we suggest reading through the <a href="https://github.com/purescript-halogen/purescript-halogen/tree/master/docs/guide">Halogen Guide</a> to learn Halogen.</p>
<h1><a class="header" href="#halogen-changelog" id="halogen-changelog">Halogen Changelog</a></h1>
<p>Halogen's major versions come with transition guides that explain how to migrate your code from one version to the next, along with summaries and the motivation for major changes to the library.</p>
<p>Currently these major versions are supported:</p>
<ul>
<li><a href="changelog/./v7.html">v7</a></li>
<li><a href="changelog/./v6.html">v6</a></li>
<li><a href="changelog/./v5.html">v5</a></li>
</ul>
<h1><a class="header" href="#changes-in-v6" id="changes-in-v6">Changes in v6</a></h1>
<p>This is a crash-course on the changes from Halogen 5 to Halogen 6. Please open an issue or PR if you notice missing information or ways this guide could be improved!</p>
<p>Halogen 6 introduces several quality-of-life improvements for using Halogen on a day-to-day basis, without major changes to how you use the library to build your applications. It's an intentionally small release which adds polish to the library and which is the first version to support version 0.14 of the PureScript compiler.</p>
<p>If you are migrating an application from Halogen 5 we recommend reading through the full transition guide. However, you can also hop directly to a relevant section using the table of contents below.</p>
<ol>
<li><a href="changelog/v6.html#purescript-014">PureScript 0.14</a></li>
<li><a href="changelog/v6.html#component-types">Component Types</a></li>
<li><a href="changelog/v6.html#event-handler-types">Event Handler Types</a></li>
<li><a href="changelog/v6.html#query-helper-functions">Query Helper Functions</a></li>
<li><a href="changelog/v6.html#subscriptions">Subscriptions</a></li>
<li><a href="changelog/v6.html#other-changes">Other Changes</a></li>
</ol>
<h2><a class="header" href="#purescript-014" id="purescript-014">PureScript 0.14</a></h2>
<p>Halogen 6 is the first version of Halogen compatible with PureScript 0.14. You'll need PureScript 0.14 to compile the library, and if you're upgrading your application to use PureScript 0.14 then you'll need to be on Halogen 6. We know it can be painful dealing with compiler changes <em>and</em> library changes, so we've kept this release intentionally small.</p>
<h2><a class="header" href="#component-types" id="component-types">Component Types</a></h2>
<p>Component types have been simplified by removing the <code>surface</code> parameter.</p>
<p>In Halogen 5 (and prior versions), components and the internal functions which manage them carried a <code>surface</code> parameter which indicated the target for the UI to render. As no one ever wrote an alternate target from <code>HTML</code>, Halogen applications have always fixed this parameter to <code>HTML</code> in component definitions, as in:</p>
<pre><code class="language-purs">import Halogen as H
import Halogen.HTML as HH

myComponent :: forall q i o m. H.Component HH.HTML q i o m
</code></pre>
<p>In Halogen 6 the <code>surface</code> parameter has been removed. The only real user-visible change is that components and functions which operate on them no longer carry the <code>surface</code> parameter.</p>
<pre><code class="language-purs">import Halogen as H

myComponent :: forall q i o m. H.Component q i o m
</code></pre>
<p>This is a breaking change, but one which is easily fixed: remove this parameter from your components and any related functions and types.</p>
<p>Added in <a href="https://github.com/purescript-halogen/purescript-halogen/pull/616">#616</a>.</p>
<h2><a class="header" href="#event-handler-types" id="event-handler-types">Event Handler Types</a></h2>
<p>We've also made event handlers a little nicer to work with. The <code>Maybe action</code> return value has been removed from event handlers, which now return <code>action</code> directly.</p>
<p>In Halogen 5, when you wanted to respond to a click event, or a message from a child component, the output was of type <code>Maybe action</code>. This allowed you to selectively emit outputs (you could emit <code>Nothing</code> for some events). In practice, though, few do this.</p>
<p>To remove friction around such a common task, these handlers no longer return in <code>Maybe</code> in Halogen 6. Instead, they return the action directly. Here is how some simple render code would change from Halogen 5 to Halogen 6:</p>
<pre><code class="language-diff"> HH.div_
   [ HH.button
-      [ HE.onClick \_ -&gt; Just Clear ]
+      [ HE.onClick \_ -&gt; Clear ]
       [ HH.text &quot;Clear&quot; ]
-   , HH.slot _id unit component unit (Just &lt;&lt;&lt; Handle)
+   , HH.slot _id unit component unit Handle
   ]
</code></pre>
<p>You're no longer able to ignore the output of a child component by providing a handler <code>\_ -&gt; Nothing</code>. Instead, you can use the <code>slot_</code> function if you don't care about a child component's output. This code from Halogen 5:</p>
<pre><code class="language-purs">HH.slot _id unit component unit (\_ -&gt; Nothing)
</code></pre>
<p>becomes this code in Halogen 6:</p>
<pre><code class="language-purs">HH.slot_ _id unit component unit
</code></pre>
<p>Note: You can recover the old Halogen 5 behavior by adding a <code>DoNothing</code> constructor to your action type, or by wrapping your action type in <code>Maybe</code>.</p>
<p>Added in <a href="https://github.com/purescript-halogen/purescript-halogen/pull/636/">#636</a> and <a href="https://github.com/purescript-halogen/purescript-halogen/pull/642">#642</a>.</p>
<h2><a class="header" href="#query-helper-functions" id="query-helper-functions">Query Helper Functions</a></h2>
<p>We've simplified the helper functions which are used with queries so that you can use <code>tell</code> and <code>request</code> directly, rather than use them in conjunction with the <code>query</code> and <code>request</code> functions.</p>
<p>In Halogen 5, to execute a query you would use the <code>query</code> function and combine it with the <code>request</code> function (for request-style queries, which return a result) or the <code>tell</code> function (for tell-style queries, which don't return a result). This was always a bit difficult to explain and easy to trip over when writing queries yourself.</p>
<p>Here's how you would execute a request-style and then a tell-style query in Halogen 5:</p>
<pre><code class="language-purs">handleAction = do
  a &lt;- H.query _a unit (H.request Child.SomeRequestQuery)
  _ &lt;- H.query _a unit (H.tell Child.SomeTellQuery)
</code></pre>
<p>In Halogen 6, you no longer use the <code>query</code> function. Instead, you use <code>request</code> and <code>tell</code> directly. You also don't have to throw away the result of <code>tell</code>, as it can already be safely discarded:</p>
<pre><code class="language-purs">handleAction = do
  a &lt;- H.request _a unit Child.SomeRequestQuery
  H.tell _a unit Child.SomeTellQuery
</code></pre>
<p>The old <code>tell</code> and <code>request</code> functions still exist in Halogen 6, but they've been renamed to <code>mkTell</code> and <code>mkRequest</code> and are only used when querying the root of your application. For example, this code in Halogen 5:</p>
<pre><code class="language-purs">io &lt;- runUI component unit body

state &lt;- io.query $ H.request SomeRequestQuery
_ &lt;- io.query $ H.tell SomeTellQuery
</code></pre>
<p>becomes this code in Halogen 6:</p>
<pre><code class="language-purs">io &lt;- runUI component unit body

state &lt;- io.query $ H.mkRequest SomeRequestQuery
_ &lt;- io.query $ H.mkTell SomeTellQuery
</code></pre>
<p>Added in <a href="https://github.com/purescript-halogen/purescript-halogen/pull/621">#621</a>.</p>
<h2><a class="header" href="#subscriptions-1" id="subscriptions-1">Subscriptions</a></h2>
<p>Event sources have been replaced with the new <a href="https://github.com/purescript-halogen/purescript-halogen-subscriptions"><code>halogen-subscriptions</code></a> library. The previous implementation of event sources was built on top of <a href="https://github.com/purescript-contrib/purescript-coroutines"><code>coroutines</code></a>. This update simplifies the library internals and connects Halogen with a subscription management library that can be used independently of Halogen itself.</p>
<p>Notable changes include:</p>
<ul>
<li>The entire <code>Halogen.Query.EventSource</code> module has been removed and replaced with <code>Halogen.Query.Event</code> which provides only an <code>eventListener</code> function. The new function is a drop-in replacement for the old <code>eventListenerEventSource</code>, so all you need to do is update your import.</li>
<li><code>affEventSource</code> and <code>effectEventSource</code> functions can be trivially replaced with code using the <code>halogen-subscriptions</code> library directly, so they have been removed. Examples of how to rewrite these functions are below.</li>
<li>The other helper functions and types from the <code>Halogen.Query.EventSource</code> module are no longer required.</li>
<li>The <code>subscribe</code> function and <code>Subscribe</code> constructor no longer take an <code>EventSource m action</code> to subscribe to. They take an <code>Emitter action</code> instead.</li>
<li>The <code>HalogenIO</code> type returned by running your root-level component now contains a <code>messages :: Emitter output</code> instead of a <code>subscribe :: Coroutine.Consumer output m Unit -&gt; m Unit</code>.</li>
</ul>
<p>If you were previously using <code>effectEventSource</code>, then you would change this Halogen 5 code:</p>
<pre><code class="language-purs">import Halogen as H
import Halogen.Query.EventSource as ES

do
  void $ H.subscribe $ ES.effectEventSource \emitter -&gt; do
    ES.emit emitter MyAction
    pure mempty
</code></pre>
<p>with this Halogen 6 code:</p>
<pre><code class="language-purs">import Halogen as H
import Halogen.Subscription as HS

do
  { emitter, listener } &lt;- H.liftEffect HS.create
  void $ H.subscribe emitter
  H.liftEffect $ HS.notify listener MyAction
</code></pre>
<p>When running your root component, you'll also need to replace your use of coroutines. For example, this Halogen 5 code:</p>
<pre><code class="language-purs">main :: Effect Unit
main = ...
  io &lt;- runUI component unit body
  io.subscribe $ Coroutine.consumer \msg -&gt; do
     ...
</code></pre>
<p>should be replaced with this Halogen 6 code:</p>
<pre><code class="language-purs">main :: Effect Unit
main = ...
  io &lt;- runUI component unit body
  _ &lt;- liftEffect $ HS.subscribe io.messages \msg -&gt; do
     ...
</code></pre>
<h2><a class="header" href="#other-changes" id="other-changes">Other changes</a></h2>
<p>Halogen 6 is an intentionally small release because it coincides with the PureScript 0.14 release. There are only a few other changes in the library to report:</p>
<ul>
<li>The <code>id_</code> function has been renamed to <code>id</code> now that <code>id</code> has been renamed to <code>identity</code> in the PureScript Prelude. <code>id_</code> continues to work, but has a deprecation notice and will be removed in the next version. See <a href="https://github.com/purescript-halogen/purescript-halogen/pull/717">#717</a>.</li>
<li>PureScript 0.14 <a href="https://github.com/purescript/purescript-prelude/blob/212e48692be1126d3eb7e0a1fc89e452cb82acfd/src/Data/Symbol.purs#L10-L13">deprecated the <code>SProxy</code> type in favor of the simpler <code>Proxy</code> type</a>. For this reason, all usages of <code>SProxy</code> in Halogen have been replaced with <code>Proxy</code>. You can do the same in your application with a simple find/replace which replaces <code>SProxy</code> with <code>Proxy</code> and the import <code>Data.Symbol (SProxy(..))</code> with <code>Type.Proxy (Proxy(..))</code>.</li>
<li>The <code>AttrName</code>, <code>PropName</code>, and <code>ClassName</code> types from Halogen have been migrated into the <a href="https://github.com/purescript-web/purescript-web-html"><code>web-html</code></a> library and imported back into Halogen. This allows libraries to share these types rather than re-implement them over and over. These types are re-exported from Halogen, so your code doesn't need to change.</li>
</ul>
<h1><a class="header" href="#changes-in-v5" id="changes-in-v5">Changes in v5</a></h1>
<p>This is a crash-course guide to things that have changed from Halogen 4 to Halogen 5. Please open an issue or a PR if you notice missing information or ways this transition guide could be improved!</p>
<p>Halogen 5 introduces many improvements to Halogen's performance and usability. If you are migrating an application from Halogen 4 we recommend reading through the full transition guide. However, you can also hop directly to a relevant section using the table of contents below.</p>
<ol>
<li><a href="changelog/v5.html#component-constructors-html-and-dsl-types">Component Constructors, HTML, and DSL Types</a></li>
<li><a href="changelog/v5.html#queries-and-actions">Queries and Actions</a></li>
<li><a href="changelog/v5.html#component-evaluation">Component Evaluation</a></li>
<li><a href="changelog/v5.html#child-component-addressing">Child Component Addressing</a></li>
<li><a href="changelog/v5.html#subscriptions-forking-and-event-sources">Subscriptions, Forking, and Event Sources</a></li>
<li><a href="changelog/v5.html#performance-optimization-with-lazy-and-memoized">Performance Optimization with Lazy and Memoized</a></li>
<li><a href="changelog/v5.html#other-changes">Other Changes</a></li>
</ol>
<h2><a class="header" href="#component-constructors-html-and-dsl-types" id="component-constructors-html-and-dsl-types">Component Constructors, HTML, and DSL Types</a></h2>
<p>Halogen 4 distinguished among parent- and child-specific for the HTML and DSL types used when defining a component, and between parent-, child-, and lifecycle-specific functions for constructing components.</p>
<p>Halogen 5 uses only one component constructor function, <code>mkComponent</code>, one type for HTML, <code>ComponentHTML</code>, and one type for component evaluation, <code>HalogenM</code>.</p>
<p>For example, a parent component would previously be defined with the <code>parentComponent</code> constructor and use the <code>ParentHTML</code> and <code>ParentDSL</code> type synonyms:</p>
<pre><code class="language-purs">parentComponent :: H.Component HH.HTML Query Input Message m
parentComponent =
  H.parentComponent
    ...
  where
  render :: State  -&gt; H.ParentHTML Query ChildQuery Slots m

  eval
    :: Query
    ~&gt; H.ParentDSL State Query ChildQuery Slots Message m
</code></pre>
<p>Whereas a child component would be defined with the <code>component</code> constructor and use the <code>ComponentHTML</code> and <code>ComponentDSL</code> type synonyms:</p>
<pre><code class="language-purs">childComponent :: H.Component HH.HTML Query Input Message m
childComponent =
  H.component
    ...
  where
  render :: State -&gt; H.ComponentHTML Query

  eval :: Query ~&gt; H.ComponentDSL State Query Message m
</code></pre>
<p>A component which used lifecycles (an initializer and/or finalizer) would be constructed with yet another pair of constructor functions:</p>
<pre><code class="language-purs">parentComponentWithLifecycles = H.lifecycleParentComponent ...
childComponentWithLifecycles = H.lifecycleComponent ...
</code></pre>
<p>In Halogen 5, the only component constructor is <code>mkComponent</code>, the only type for HTML is <code>ComponentHTML</code>, and the only type for component evaluation is <code>HalogenM</code>.</p>
<p>Due to changes in queries and evaluation in Halogen 5, these types are not the same as they were in Halogen 4. We'll explore those changes in the next section.</p>
<h2><a class="header" href="#queries-and-actions" id="queries-and-actions">Queries and Actions</a></h2>
<p>In Halogen 4, a component's query algebra defines everything the component can do. In Halogen 5, queries are only for parent-child communication, and a simpler action type is used within the component.</p>
<p>Previously, queries were the only type for defining computations the component can run. Queries were paired with the <code>eval</code> function, which defines the computation that should run when a query happens. There were two ways to write a query: &quot;action-style&quot; and &quot;request-style&quot;:</p>
<pre><code class="language-purs">data Query a
  = HandleClick a
  | RespondWithInt (Int -&gt; a)
</code></pre>
<p>Action-style queries like <code>HandleClick</code> don't return anything when they are run by the <code>eval</code> function, whereas request-style queries like <code>RespondWithInt</code> do return a result. Correspondingly, action-style queries were typically used to handle events arising from HTML or event sources, and request-style queries were used for parent-child component communication.</p>
<p>In Halogen 5 this distinction has been made explicit. Components now use two separate types to represent computations: a query type for parent-child communication and an action type for internal events (like those arising from HTML or event sources).</p>
<p>The above query type from Halogen 4 would become, in Halogen 5, these two definitions:</p>
<pre><code class="language-purs">-- Actions don't need to be parameterised because they can't
-- return a value. Actions are used instead of queries in
-- ComponentHTML and to handle event sources.
data Action
  = HandleClick

-- Queries are the same as they were in Halogen 4, but are
-- used specifically for parent-child communication instead of
-- being used to represent all computations in a component.
data Query a
  = RespondWithInt (Int -&gt; a)
</code></pre>
<p>Actions don't show up in the type of the component because they cannot be accessed outside of the component:</p>
<pre><code class="language-purs">component :: forall m. H.Component Query Input Output m
</code></pre>
<h3><a class="header" href="#changes-to-query-evaluation" id="changes-to-query-evaluation">Changes to Query Evaluation</a></h3>
<p>Queries are still used as the public interface for a component, which means they are useful for parent-child communication. They aren't required, however: many components are self-contained and only need actions.</p>
<p>There have been a few other tweaks to queries in Halogen 5 worth knowing about.</p>
<p>You can still write &quot;action-style&quot; queries, but to avoid terminology overloading, they're now termed &quot;tell-style&quot; queries and are constructed using <code>H.tell</code> instead of <code>H.action</code>.</p>
<pre><code class="language-purs">data MyQuery a
  = DoSomething a

-- Halogen 4
result &lt;- H.query ... $ H.action DoSomething

-- Halogen 5
result &lt;- H.query ... $ H.tell DoSomething
</code></pre>
<p>In addition, query evaluation in Halogen 5 can now &quot;fail&quot; without resorting to throwing exceptions. Query evaluation in Halogen 5 is now of the type:</p>
<pre><code class="language-purs">query a -&gt; HalogenM ... (Maybe a)
</code></pre>
<p>instead of the Halogen 4 type:</p>
<pre><code class="language-purs">query ~&gt; HalogenM ...
</code></pre>
<p>If evaluation returns <code>Nothing</code> for a query, then it will be flattened during the call to <code>H.query</code> and become indistinguishible from the case in which the component being queried doesn't exist.</p>
<h3><a class="header" href="#introducing-actions" id="introducing-actions">Introducing Actions</a></h3>
<p>Actions are now used to represent computations internal to a component. They are of the kind <code>Type</code> instead of <code>Type -&gt; Type</code> because, unlike queries, they can't return anything.</p>
<pre><code class="language-purs">data Action
  = Increment
  | Decrement
</code></pre>
<p>Internally, actions are evaluated similarly to how queries are evaluated, with a function of the type:</p>
<pre><code class="language-purs">action -&gt; HalogenM ... Unit
</code></pre>
<p>This action type is now used in place of the query type in your render function:</p>
<pre><code class="language-purs">-- Halogen 4
render :: State -&gt; H.ParentHTML Query ChildQuery Slots m
render :: State -&gt; H.ComponentHTML Query

-- Halogen 5
render :: State -&gt; H.ComponentHTML Action Slots m
</code></pre>
<p>We're no longer using <code>Query</code> in the the Halogen 5 version. (We're not using <code>ChildQuery</code> either, but that's unrelated -- that's due to changes in how slots work in Halogen 5, which we'll address in a moment.)</p>
<p>One last thing about actions: since they are not of kind <code>Type -&gt; Type</code>, helper functions like <code>input</code> and <code>input_</code> are no longer necessary when handling events in HTML, and so they have been removed in Halogen 5</p>
<pre><code class="language-purs">-- Halogen 4
module Halogen.HTML.Events where

type Action f = Unit -&gt; f Unit

input  :: forall f a. (a -&gt; Action f) -&gt; a -&gt; Maybe (f Unit)
input_ :: forall f a. Action f -&gt; a -&gt; Maybe (f Unit)
</code></pre>
<p>In Halogen 4 these functions were used to transform queries in the render function:</p>
<pre><code class="language-purs">-- Halogen 4
import Halogen.HTML as HH
import Halogen.HTML.Events as HE

data Query a
  = Toggle a
  | Hover MouseEvent a

render :: State -&gt; H.ComponentHTML Query
render =
  HH.button
    [ HE.onClick (HE.input_ Toggle)
    , HE.onMouseOver (HE.input Hover)
    ]
    [ HH.text &quot;Click me&quot; ]
</code></pre>
<p>This is how you'd write the same code in Halogen 5:</p>
<pre><code class="language-purs">-- Halogen 5
data Action
  = Toggle
  | Hover MouseEvent

render :: forall m. State -&gt; H.ComponentHTML Action Slots m
render =
  HH.button
    [ HE.onClick \_ -&gt; Just Toggle
    , HE.onMouseOver (Just &lt;&lt;&lt; Hover)
    ]
    [ HH.text &quot;Click me&quot; ]
</code></pre>
<h3><a class="header" href="#mixing-queries-and-actions" id="mixing-queries-and-actions">Mixing Queries and Actions</a></h3>
<p>Now that actions and queries have been split apart you may want to share some of the behavior between actions and queries without duplicating the constructors and/or implementation. You can do that by adding a constructor to your action type which allows you to use your action-style queries:</p>
<pre><code class="language-purs">data Query a
  = UpdateState a

data Action
  = HandleClick
  | EvalQuery (Query Unit)
</code></pre>
<p>Then, you can evaluate the &quot;action-style&quot; query when it arises as an action by unwrapping it and passing it your query evaluation function.</p>
<p>While it's also possible to add an <code>EvalAction Action a</code> constructor to your query type, this isn't recommended. The action type can be used to hide internal interactions that shouldn't be called externally, but the query type is always fully public.</p>
<h2><a class="header" href="#component-evaluation" id="component-evaluation">Component Evaluation</a></h2>
<p>Component evaluation has changed now that there is only one constructor, <code>mkComponent</code>, no differentiation between child, parent, and lifecycle components, and an explicit separation between actions and queries.</p>
<p>In Halogen 4, the <code>component</code> constructor had separate fields for the <code>eval</code> function (handling queries) and the <code>receiver</code> function (handling component input), and the <code>lifecycleComponent</code> had additional fields for <code>initializer</code> and <code>finalizer</code> to handle lifecycle events.</p>
<p>In Halogen 5, the <code>mkComponent</code> constructor has just a single evaluation function, <code>eval</code>, which handles all the various kinds of events a component can encounter, including lifecycles, component input, queries, and actions.</p>
<pre><code class="language-purs">eval
  :: HalogenQ query action input
  ~&gt; HalogenM state action slots output m
</code></pre>
<p>In a moment we'll examine the <code>eval</code> function in-depth, but in most cases you'll construct it with the <code>mkEval</code> helper function paired with <code>defaultEval</code>, which provides default values for handling each of these cases. If <code>defaultEval</code> is used with no overrides the component will do nothing for any action raised internally, and any queries made of it will fail.</p>
<p>Here are a few different eval functions which handle various cases:</p>
<pre><code class="language-purs">-- This eval function does nothing
H.mkComponent
  { initialState: ...
  , render: ...
  , eval: H.mkEval H.defaultEval
  }

-- This one handles only actions
eval = H.mkEval $ H.defaultEval
  { handleAction = \action - &gt; ...
  }

-- This one handles actions, queries, and initialization:
data Action = Initialize

eval = H.mkEval $ H.defaultEval
  { handleAction = \action -&gt; ...
  , handleQuery = \query -&gt; ...
  , initialize = Just Initialize
  }
</code></pre>
<p>As you can tell, the <code>eval</code> function is no longer just for handling queries. Instead, it handles all the cases expressed by <code>HalogenQ</code>, a type that captures the various sorts of input that can be evaluated in a component:</p>
<pre><code class="language-purs">data HalogenQ query action input a
  = Initialize a
  | Finalize a
  | Receive input a
  | Action action a
  | Query (Coyoneda query a) (Unit -&gt; a)
</code></pre>
<p>You can write an <code>eval</code> function manually by pattern-matching on each of these constructors, but in most cases you should use the new <code>mkEval</code> helper function. This function accepts a record that looks similar to the old <code>lifecycleComponent</code> constructor:</p>
<pre><code class="language-purs">type EvalSpec state query action slots input output m =
   { handleAction
       :: action
       -&gt; HalogenM state action slots output m Unit
   , handleQuery
       :: forall a
        . query a
       -&gt; HalogenM state action slots output m (Maybe a)
   , receive :: input -&gt; Maybe action
   , initialize :: Maybe action
   , finalize :: Maybe action
   }
</code></pre>
<p>The <code>defaultEval</code> function provides default values for each of these handlers, which do nothing, and which you can override using ordinary PureScript record syntax:</p>
<pre><code class="language-purs">-- This eval function uses the defaults, but overrides the
-- `handleAction` and `handleQuery` functions.
eval = H.mkEval $ H.defaultEval
  { handleAction = case _ of ...
  , handleQuery = case _ of ...
  }
</code></pre>
<h2><a class="header" href="#child-component-addressing" id="child-component-addressing">Child Component Addressing</a></h2>
<p>Halogen 4 used two types to determine information necessary to render and query child components: the child component query type and a slot value used to identify a particular child component.</p>
<p>These types were unpleasant to work with when a component had multiple types of child component because they required nested <code>Coproduct</code> and <code>Either</code> types to accomodate everything, and you had to remember the order you listed your child component types in when using the <code>slot</code> or <code>query</code> functions.</p>
<pre><code class="language-purs">-- Halogen 4

type ChildQuery =
  Coproduct3
    ComponentA.Query
    ComponentB.Query
    ComponentC.Query

type ChildSlot = Either3 Unit Int Unit

render :: forall m. State -&gt; H.ParentHTML Query ChildQuery ChildSlot m
render state =
  HH.div_
    [ HH.slot' CP.cp1 ComponentA.component unit absurd
    , HH.slot CP.cp2 1 ComponentB.component unit absurd
    , HH.slot' CP.cp3 ComponentC.component unit absurd
    ]
</code></pre>
<p>In Halogen 5, all of this has been consolidated to a single row type where labels identify different child component types and the label's associated <code>H.Slot</code> value specifies the query, output, and slot type for the child component.</p>
<p>We can replace the <code>ChildQuery</code> and <code>ChildSlot</code> types with a single row type:</p>
<pre><code class="language-purs">-- Halogen 5
type Slots =
  ( a :: H.Slot ComponentA.Query Void Unit
  , b :: H.Slot ComponentB.Query Void Int
  , c :: H.Slot ComponentC.Query Void Unit
  )
</code></pre>
<p>Instead of using <code>ChildPath</code> types (<code>cp1</code>, <code>cp2</code>, <code>cp3</code>, etc.) to identify components and slots, we now use symbol proxies for the labels in the row:</p>
<pre><code class="language-purs">_a = SProxy :: SProxy &quot;a&quot;
_b = SProxy :: SProxy &quot;b&quot;
_c = SProxy :: SProxy &quot;c&quot;

render :: forall m. State -&gt; H.ComponentHTML Action Slots m
render state =
  HH.div_
    [ HH.slot _a unit ComponentA.component unit absurd
    , HH.slot _b 1 ComponentB.component unit absurd
    , HH.slot _c unit ComponentC.component unit absurd
    ]
</code></pre>
<p>This may look similar on the surface to the prior non-row child query and child slot types, but in practice it is <em>much</em> nicer to deal with -- especially if you were one of the people out there who needed more than 10 types of child component, as we only provided helper types and premade <code>ChildPath</code> values up to that.</p>
<p>In Halogen 4 the <code>slot</code>, <code>query</code>, and <code>queryAll</code> had primed variants, <code>slot'</code>, <code>query'</code>, and <code>queryAll'</code>, where the non-primed variants let you skip the <code>ChildPath</code> argument for components with only one type of child component.</p>
<p>In Halogen 5 there are only the un-primed variants. You must always provide an <code>SProxy</code> to the <code>slot</code>, <code>query</code>, and <code>queryAll</code> functions to identify the child component you are targeting.</p>
<p>The new row-based approach allows you greater flexibility to define helpers that work on slot types. For example, a common pattern in Halogen 5 applications is to define a <code>Slot</code> type synonym for a component in the same module in which the component is defined. This type synonym can specify the query and message types but leave the slot value unspecified, for a parent component to choose.</p>
<p>For example, if each of the <code>ComponentA</code>, <code>ComponentB</code>, and <code>ComponentC</code> modules in the example above had been defined with a type synonym for their slot type already:</p>
<pre><code class="language-purs">module ComponentA where

type Slot = H.Slot Query Void

data Query = ...

component :: forall i o m. H.Component Query i Void m
</code></pre>
<p>Then parent components don't need to worry about specifying the query or message types for the child component:</p>
<pre><code class="language-purs">type Slots =
  ( a :: ComponentA.Slot Unit
  , b :: ComponentB.Slot Int
  , c :: ComponentC.Slot Unit
  )
</code></pre>
<h2><a class="header" href="#subscriptions-forking-and-event-sources" id="subscriptions-forking-and-event-sources">Subscriptions, Forking, and Event Sources</a></h2>
<p>Halogen 5 introduces a number of ergonomic improvements to subscriptions, forking, and event sources, including a new <code>EventSource</code> API.</p>
<h3><a class="header" href="#subscriptions-2" id="subscriptions-2">Subscriptions</a></h3>
<p>The <code>subscribe</code> function in Halogen 5 now returns a <code>SubscriptionId</code> value that allows a subscription to be cancelled later with <code>unsubscribe</code>. Subscriptions could previously only be ended in response to an event -- the event source would close itself.</p>
<p>It's still possible for a subscription to unsubscribe itself. The <code>subscribe'</code> function passes the <code>SubscriptionId</code> into a function which returns the <code>EventSource</code>. That way the <code>EventSource</code> can raise an action with the relevant <code>SubscriptionId</code>.</p>
<h3><a class="header" href="#event-sources" id="event-sources">Event Sources</a></h3>
<p>Halogen 5 simplifies the <code>EventSource</code> API by introducing a new <code>Emitter</code> type and reducing the many, many variations of event source construction helpers to just <code>affEventSource</code>, <code>effectEventSource</code>, and <code>eventListenerEventSource</code>. Event sources now use queries instead of actions, and no longer require event handlers to return a subscription status.</p>
<p>Event sources have simpler types in Halogen 5:</p>
<pre><code class="language-purs">-- Halogen 4
newtype EventSource f m =
  EventSource (m
    { producer :: CR.Producer (f SubscribeStatus) m Unit
    , done :: m Unit
    })

-- Halogen 5
newtype EventSource m a =
  EventSource (m
    { producer :: CR.Producer a m Unit
    , finalizer :: Finalizer m
    })
</code></pre>
<p>But it's not common to manually create an event source. Instead, you should use the new <code>affEventSource</code> and <code>effectEventSource</code> helper functions:</p>
<pre><code class="language-purs">affEventSource
  :: forall m a
   . MonadAff m
  =&gt; (Emitter Aff a -&gt; Aff (Finalizer Aff))
  -&gt; EventSource m a

effectEventSource
  :: forall m a
   . MonadAff m
  =&gt; (Emitter Effect a -&gt; Effect (Finalizer Effect))
  -&gt; EventSource m a
</code></pre>
<p>These functions let you set up a new event source from a setup function. This setup function operates in <code>Aff</code> or <code>Effect</code> and allows you to emit actions to the current component (or close the event source) using the <code>Emitter</code>. The setup function returns a <code>Finalizer</code> to run when the event source is unsubscribed or the emitter is closed.</p>
<p>The <code>emit</code> function allows you to emit an action using the emitter provided by the <code>affEventSource</code> and <code>effectEventSource</code> functions. The <code>close</code> function lets you close the emitter and shut down the event source.</p>
<p>For example, this example creates an event source which will emit the <code>Notify</code> action after one second and then close the event source:</p>
<pre><code class="language-purs">data Action = Notify String

myEventSource :: EventSource Aff Action
myEventSource = EventSource.affEventSource \emitter -&gt; do
  Aff.delay (Milliseconds 1000.0)
  EventSource.emit emitter (Notify &quot;hello&quot;)
  EventSource.close emitter
  pure mempty
</code></pre>
<p>There is also an <code>eventListenerEventSource</code> function which you can use to set up an event source that listens to events in the DOM.</p>
<pre><code class="language-purs">eventListenerEventSource
  :: forall m a
   . MonadAff m
  =&gt; EventType
  -&gt; EventTarget
  -&gt; (Event -&gt; Maybe a)
  -&gt; EventSource m a
</code></pre>
<p>For example, we can subscribe to changes in the browser window width:</p>
<pre><code class="language-purs">data Action = Initialize | Handler Window

handleAction = case _ of
  Initialize -&gt;
    void $ H.subscribe do
      ES.eventListenerEventSource
        (EventType &quot;resize&quot;)
        (Window.toEventTarget window)
        (Event.target &gt;&gt;&gt; map (fromEventTarget &gt;&gt;&gt; Handler))

  Handler window -&gt;
    width &lt;- liftEffect (innerWidth window)
    -- ...do something with the window width
</code></pre>
<p>When using event sources in components, you no longer need to respond to events with a <code>SubscribeStatus</code>:</p>
<pre><code class="language-purs">-- Halogen 4
eval = case _ of
  HandleChange reply -&gt; do
    -- ... your code
    pure (reply H.Listening)

-- Halogen 5
handleAction = case _ of
  HandleChange -&gt;
    -- ... your code
</code></pre>
<h3><a class="header" href="#forks" id="forks">Forks</a></h3>
<p>In Halogen 4 the <code>H.fork</code> function returned a canceller function.</p>
<p>In Halogen 5 it returns a <code>ForkId</code>, which you can pass to the <code>H.kill</code> function to cancel the fork. This mirrors the <code>H.subscribe</code> function. Forks are now killed when a component is finalized, unless the fork occurred during finalization.</p>
<h2><a class="header" href="#performance-optimization-with-lazy-and-memoized" id="performance-optimization-with-lazy-and-memoized">Performance Optimization with Lazy and Memoized</a></h2>
<p>Halogen 5 introduces the ability to skip rendering for arbitrary HTML trees, not just at component boundaries as was the case in Halogen 4.</p>
<p>The new <code>memoized</code> function lets you skip rendering a tree of HTML given an equality predicate. If an argument is deemed equivalent to the value in the previous render then rendering and diffing will be skipped.</p>
<pre><code class="language-purs">memoized
  :: forall a action slots m
   . (a -&gt; a -&gt; Boolean)
  -&gt; (a -&gt; ComponentHTML action slots m)
  -&gt; a
  -&gt; ComponentHTML action slots m
</code></pre>
<p>For example, you can skip rendering for equal state values by wrapping your component's render function:</p>
<pre><code class="language-purs">myComponent = component
  { ...
  , render: memoized eq render
  , ...
  }
</code></pre>
<p>You can also skip rendering for referentially-equal arguments using the <code>lazy</code>, <code>lazy2</code>, and <code>lazy3</code> functions. These work like <code>memoized</code>, but instead of taking an equality predicate they use referential equality.</p>
<p>Here's an example of skipping rendering a large list of items when the state it depends on is unchanged between renders:</p>
<pre><code class="language-purs">-- Before
render state =
  HH.div_ [ generateItems state.totalItems ]

-- After
render state =
  HH.div_ [ HH.lazy generateItems state.totalItems ]
</code></pre>
<p>These functions are a convenient way to wring extra performance out of your render code.</p>
<h2><a class="header" href="#other-changes-1" id="other-changes-1">Other Changes</a></h2>
<p>Halogen 5 has also seen a number of other miscellaneous changes. These are quality of life improvements that don't affect many common workflows but which are worth noting.</p>
<h3><a class="header" href="#halt-and-halogenm" id="halt-and-halogenm"><code>Halt</code> and HalogenM</a></h3>
<p>The <code>Halt</code> constructor was removed from <code>HalogenM</code>. If a component needs to explode in that way, it should be done by lifting something into the component's <code>m</code> instead.</p>
<p>If <code>Halt</code> was being used for an infallible case in a higher order component <code>eval</code>, the same effect can be achieved now by returning <code>Nothing</code>.</p>
<p>If this doesn't mean anything to you, don't worry about it! Halting wasn't explained anywhere previously and was used internally for the most part.</p>
<h3><a class="header" href="#driverio-and-app-disposal" id="driverio-and-app-disposal"><code>DriverIO</code> and App Disposal</a></h3>
<p>The <code>DriverIO</code> type has been renamed to <code>HalogenIO</code>. You can now <code>dispose</code> of an entire Halogen app via the <code>HalogenIO</code> record returned from <code>runUI</code>. This will remove everything from the DOM and finalize the components. Attempting to <code>query</code> the <code>DriverIO</code> after this will return <code>Nothing</code>.</p>
<h3><a class="header" href="#updated-examples" id="updated-examples">Updated Examples</a></h3>
<p>The examples have been changed to try and best illustrate the feature they relate to, and just generally tidied up a bit. Some specifics:</p>
<ul>
<li>The <code>interpret</code> example now works on a component that is using a <code>ReaderT</code> over <code>Aff</code> rather than a <code>Free</code> monad. <code>ReaderT</code> + <code>Aff</code> is a very common real world setup for an app's effect monad.</li>
<li>The <code>higher-order-components</code> example shows a expandable/collapsible container box kind of thing that allows interactions with the inner component when it is expanded.</li>
<li>The <code>todo</code> example has gone, as it was intended to show a fairly-but-not-entirely trivial example, but had weird conventions that nobody uses. <a href="https://github.com/thomashoneyman">@thomashoneyman</a>'s <a href="https://github.com/thomashoneyman/purescript-halogen-realworld">Real World Halogen</a> is a much better and more comprehensive example of how an app might be structured and is up-to-date for Halogen 5.</li>
</ul>
<h3><a class="header" href="#file-inputs" id="file-inputs">File Inputs</a></h3>
<p>The <code>accept</code> property (for file inputs) didn't have quite the right type before, it accepted a <code>MediaType</code>, but really should have allowed a collection of media types and file extensions. The type has been changed to a new <code>InputAcceptType</code> monoid to fix this.</p>
<h3><a class="header" href="#longer-type-variables-in-type-signatures" id="longer-type-variables-in-type-signatures">Longer Type Variables in Type Signatures</a></h3>
<p>The type variables have been renamed to full words in the component / query / etc. type signatures. Maybe this will help, maybe not - feedback is welcome and appreciated!</p>
<h3><a class="header" href="#migration-to-spago" id="migration-to-spago">Migration to Spago</a></h3>
<p><a href="https://github.com/purescript/spago">Spago</a> has emerged as the preferred dependency manager and build tool for PureScript. Halogen 5 -- both the library and the examples -- is now migrated entirely to Spago, with Bower used solely for publication.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
