<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Introducing Components - Halogen Guide</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Halogen</a></li><li class="chapter-item expanded "><a href="../guide/index.html"><strong aria-hidden="true">2.</strong> Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../guide/01-Rendering-Halogen-HTML.html"><strong aria-hidden="true">2.1.</strong> Rendering Halogen HTML</a></li><li class="chapter-item expanded "><a href="../guide/02-Introducing-Components.html" class="active"><strong aria-hidden="true">2.2.</strong> Introducing Components</a></li><li class="chapter-item expanded "><a href="../guide/03-Performing-Effects.html"><strong aria-hidden="true">2.3.</strong> Performing Effects</a></li><li class="chapter-item expanded "><a href="../guide/04-Lifecycles-Subscriptions.html"><strong aria-hidden="true">2.4.</strong> Lifecycles &amp; Subscriptions</a></li><li class="chapter-item expanded "><a href="../guide/05-Parent-Child-Components.html"><strong aria-hidden="true">2.5.</strong> Parent &amp; Child Components</a></li><li class="chapter-item expanded "><a href="../guide/06-Running-Application.html"><strong aria-hidden="true">2.6.</strong> Running Application</a></li><li class="chapter-item expanded "><a href="../guide/07-Next-Steps.html"><strong aria-hidden="true">2.7.</strong> Next Steps</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts-reference/index.html"><strong aria-hidden="true">3.</strong> Concepts Reference</a></li><li class="chapter-item expanded "><a href="../changelog/index.html"><strong aria-hidden="true">4.</strong> Major Version Changelog</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../changelog/v6.html"><strong aria-hidden="true">4.1.</strong> Changes in v6</a></li><li class="chapter-item expanded "><a href="../changelog/v5.html"><strong aria-hidden="true">4.2.</strong> Changes in v5</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Halogen Guide</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/purescript-halogen/purescript-halogen" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introducing-components" id="introducing-components">Introducing Components</a></h1>
<p>Halogen HTML is one basic building block of Halogen applications. But pure functions that produce HTML lack many essential features that a real world application needs: state that represents values over time, effects for things like network requests, and the ability to respond to DOM events (for example, when a user clicks a button).</p>
<p>Halogen components accept input and produce Halogen HTML, like the functions we've seen so far. Unlike functions, though, components maintain internal state, can update their state or perform effects in response to events, and can communicate with other components.</p>
<p>Halogen uses a component architecture. That means that Halogen uses components to let you split your UI into independent, reusable pieces and think about each piece in isolation. You can then combine components together to produce sophisticated applications.</p>
<p>For example, every Halogen application is made up of at least one component, which is called the &quot;root&quot; component. Halogen components can contain further components, and the resulting tree of components comprises your Halogen application.</p>
<p>In this chapter we'll learn most of the essential types and functions for writing Halogen components. For a beginner, this is the hardest chapter in the guide because many of these concepts will be brand-new. Don't worry if it feels overwhelming the first time you read it! You'll use these types and functions over and over again when you write Halogen applications, and they soon become second nature. If you're having a hard time with the chapter, try reading it again while building a simple component other than the one described here.</p>
<p>In this chapter we'll also see more examples of Halogen's declarative style of programming. When you write a component you're responsible for describing what UI should exist for any given internal state. Halogen, under the hood, updates the actual DOM elements to match your desired UI.</p>
<h2><a class="header" href="#a-tiny-example" id="a-tiny-example">A Tiny Example</a></h2>
<p>We have already seen a simple example of a component: a counter that can be incremented or decremented.</p>
<pre><code class="language-purs">module Main where

import Prelude

import Halogen as H
import Halogen.HTML as HH
import Halogen.HTML.Events as HE

data Action = Increment | Decrement

component =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval H.defaultEval { handleAction = handleAction }
    }
  where
  initialState _ = 0

  render state =
    HH.div_
      [ HH.button [ HE.onClick \_ -&gt; Decrement ] [ HH.text &quot;-&quot; ]
      , HH.text (show state)
      , HH.button [ HE.onClick \_ -&gt; Increment ] [ HH.text &quot;+&quot; ]
      ]

  handleAction = case _ of
    Decrement -&gt;
      H.modify_ \state -&gt; state - 1

    Increment -&gt;
      H.modify_ \state -&gt; state + 1
</code></pre>
<p>This component maintains an integer as its internal state, and updates that state in response to click events on the two buttons.</p>
<p>This component works, but in a real world application we wouldn't leave all the types unspecified. Let's rebuild this component from scratch with all the types it uses.</p>
<h2><a class="header" href="#building-a-basic-component-with-types" id="building-a-basic-component-with-types">Building a Basic Component (With Types)</a></h2>
<p>A typical Halogen component accepts input, maintains an internal state, produces Halogen HTML from that state, and updates its state or performs effects in response to events. In this case we don't need to perform any effects, but we'll cover them soon.</p>
<p>Let's break down each part of our component, assigning types along the way.</p>
<h3><a class="header" href="#input" id="input">Input</a></h3>
<p>Halogen components can accept input from a parent component or the root of the application. If you think of a component as a function, then input is the function's argument.</p>
<p>If your component takes input, then you should describe it with a type. For example, a component that accepts an integer as input would use this type:</p>
<pre><code class="language-purs">type Input = Int
</code></pre>
<p>Our counter doesn't require any input, so we have two choices. First, we can just say that our input type is <code>Unit</code>, meaning that we'll just take a dummy value and throw it away:</p>
<pre><code class="language-purs">type Input = Unit
</code></pre>
<p>Second, and more commonly, anywhere our input type shows up in our component we can simply leave it as a type variable: <code>forall i. ...</code>. It's perfectly fine to use either approach, but from here on out we'll use type variables to represent types our component isn't using.</p>
<h3><a class="header" href="#state" id="state">State</a></h3>
<p>Halogen components maintain an internal state over time, which is used to drive the component's behavior and to produce HTML. Our counter component maintains the current count, an integer, so we'll use that as our state type:</p>
<pre><code class="language-purs">type State = Int
</code></pre>
<p>Our component needs to also produce an initial state value. All Halogen components require an <code>initialState</code> function which produces the initial state from the input value:</p>
<pre><code class="language-purs">initialState :: Input -&gt; State
</code></pre>
<p>Our counter component doesn't use its input, so our <code>initialState</code> function won't use an input type and will instead just leave that type variable open. Our counter should start at 0 when the component runs.</p>
<pre><code class="language-purs">initialState :: forall input. input -&gt; State
initialState _ = 0
</code></pre>
<h3><a class="header" href="#actions" id="actions">Actions</a></h3>
<p>Halogen components can update state, perform effects, and communicate with other components in response to events that arise internally. Components use an &quot;action&quot; type to describe what kinds of things a component can do in response to internal events.</p>
<p>Our counter has two internal events:</p>
<ol>
<li>a click event on the &quot;-&quot; button to decrement the count</li>
<li>a click event on the &quot;+&quot; button to increment the count.</li>
</ol>
<p>We can describe what our component should do in response to these events using a data type we'll call <code>Action</code>:</p>
<pre><code class="language-purs">data Action = Increment | Decrement
</code></pre>
<p>This type signifies that our component is capable of incrementing and decrementing. In a moment, we'll see this type used in our HTML -- another example of Halogen's declarative nature.</p>
<p>Just like how our state type had to be paired with an <code>initialState</code> function that describes how to produce a <code>State</code> value, our <code>Action</code> type should be paired with a function called <code>handleAction</code> that describes what to do when one of these actions occurs.</p>
<pre><code class="language-purs">handleAction :: forall output m. Action -&gt; H.HalogenM State Action () output m Unit
</code></pre>
<p>As with our input type, we can leave type variables open for types that we aren't using.</p>
<ul>
<li>The type <code>()</code> means our component has no child components. We could also leave it open as a type variable because we aren't using it -- <code>slots</code>, by convention -- but <code>()</code> is so short you'll see this type commonly used instead.</li>
<li>The <code>output</code> type parameter is only used when your component communicates with a parent.</li>
<li>The <code>m</code> type parameter is only relevant when your component performs effects.</li>
</ul>
<p>Since our counter has no child components we'll use <code>()</code> to describe them, and because it doesn't communicate with a parent or perform effects we'll leave the <code>output</code> and <code>m</code> type variables open.</p>
<p>Here's the <code>handleAction</code> function for our counter:</p>
<pre><code class="language-purs">handleAction :: forall output m. Action -&gt; H.HalogenM State Action () output m Unit
handleAction = case _ of
  Decrement -&gt;
    H.modify_ \state -&gt; state - 1

  Increment -&gt;
    H.modify_ \state -&gt; state + 1
</code></pre>
<p>Our <code>handleAction</code> function responds to <code>Decrement</code> by reducing our state variable by 1, and to <code>Increment</code> by increasing our state variable by 1. Halogen provides several update functions you can use in your <code>handleAction</code> function; these ones are commonly used:</p>
<ul>
<li><code>modify</code> allows you to update the state, given the previous state, returning the new state</li>
<li><code>modify_</code> is the same as <code>modify</code>, but it doesn't return the new state (thus you don't have to explicitly discard the result, as you would with <code>modify</code>)</li>
<li><code>get</code> allows you to retrieve the current state</li>
<li><code>gets</code> allows you to retrieve the current state and also apply a function to it (most commonly, <code>_.fieldName</code> to retrieve a particular field from a record)</li>
</ul>
<p>We'll talk more about <code>HalogenM</code> when we talk about performing effects. Our counter doesn't perform effects, so all we need are the state update functions.</p>
<h3><a class="header" href="#rendering" id="rendering">Rendering</a></h3>
<p>Halogen components produce HTML from their state using a function called <code>render</code>. The render function runs every time the state changes. This is what makes Halogen declarative: for any given state, you describe the UI that it corresponds to. Halogen handles the workload of ensuring that state changes always result in the UI you described.</p>
<p>Render functions in Halogen are pure, which means that you can't do things like get the current time, make network requests, or anything like that during rendering. All you can do is produce HTML for your state value.</p>
<p>When we look at the type of our render function we can see the <code>ComponentHTML</code> type we touched on last chapter. This type is a more specialized version of the <code>HTML</code> type, meant specifically for HTML produced in components. Once again, we'll use <code>()</code> and leave <code>m</code> open because they are only relevant when using child components, which we'll cover in a later chapter.</p>
<pre><code class="language-purs">render :: forall m. State -&gt; H.ComponentHTML Action () m
</code></pre>
<p>Now that we're working with our render function, we're back to the Halogen HTML that should be familiar from the last chapter! You can write regular HTML in <code>ComponentHTML</code> just like we did last chapter:</p>
<pre><code class="language-purs">import Halogen.HTML.Events

render :: forall m. State -&gt; H.ComponentHTML Action () m
render state =
  HH.div_
    [ HH.button [ HE.onClick \_ -&gt; Decrement ] [ HH.text &quot;-&quot; ]
    , HH.text (show state)
    , HH.button [ HE.onClick \_ -&gt; Increment ] [ HH.text &quot;+&quot; ]
    ]
</code></pre>
<h4><a class="header" href="#handling-events" id="handling-events">Handling Events</a></h4>
<p>We can now see how to handle events in Halogen. First, you write the event handler in the properties array along with any other properties, attributes, and refs you might need. Then, you associate the event handler with an <code>Action</code> that your component knows how to handle. Finally, when the event occurs, your <code>handleAction</code> function is called to handle the event.</p>
<p>You might be curious about why we provided an anonymous function to <code>onClick</code>. To see why, we can look at the actual type of <code>onClick</code>:</p>
<pre><code class="language-purs">onClick
  :: forall row action
   . (MouseEvent -&gt; action)
  -&gt; IProp (onClick :: MouseEvent | row) action

-- Specialized to our component
onClick
  :: forall row
   . (MouseEvent -&gt; Action)
  -&gt; IProp (onClick :: MouseEvent | row) Action
</code></pre>
<p>In Halogen, event handlers take as their first argument a callback. This callback receives the DOM event that occurred (in the case of a click event, that's a <code>MouseEvent</code>), which contains some metadata you may want to use, and is then responsible for returning an action that Halogen should run in response to the event. In our case, we won't inspect the event itself, so we throw the argument away and return the action we want to run (<code>Increment</code> or <code>Decrement</code>).</p>
<p>The <code>onClick</code> function then returns a value of type <code>IProp</code>. You should remember <code>IProp</code> from the previous chapter. As a refresher, Halogen HTML elements specify a list of what properties and events they support. Properties and events in turn specify their type. Halogen is then able to ensure that you never use a property or event on an element that doesn't support it. In this case buttons do support <code>onClick</code> events, so we're good to go!</p>
<p>In this simple example, the <code>MouseEvent</code> parameter is ignored by the handler function passed to <code>onClick</code>, since the action is completely determined by which button receives the click.  We will talk about accessing the event itself after we have looked at effects in section 3 of this guide.</p>
<h3><a class="header" href="#bringing-it-all-together" id="bringing-it-all-together">Bringing It All Together</a></h3>
<p>Let's bring each of our types and functions back together to produce our counter component -- this time with types specified. Let's revisit the types and functions that we wrote:</p>
<pre><code class="language-purs">-- This can be specified if your component takes input, or you can leave
-- the type variable open if your component doesn't.
type Input = Unit

type State = Int

initialState :: forall input. input -&gt; State
initialState = ...

data Action = Increment | Decrement

handleAction :: forall output m. Action -&gt; H.HalogenM State Action () output m Unit
handleAction = ...

render :: forall m. State -&gt; H.ComponentHTML Action () m
render = ...
</code></pre>
<p>These types and functions are the core building blocks of a typical Halogen component. But they aren't sufficient on their own like this -- we need to bring them all together in one place.</p>
<p>We'll do that using the <code>H.mkComponent</code> function. This function takes a <code>ComponentSpec</code>, which is a record containing an <code>initialState</code>, <code>render</code>, and <code>eval</code> function, and produces a <code>Component</code> from it:</p>
<pre><code class="language-purs">component =
  H.mkComponent
    { -- First, we provide our function that describes how to produce the first state
      initialState
      -- Then, we provide our function that describes how to produce HTML from the state
    , render
      -- Finally, we provide our function that describes how to handle actions that
      -- occur while the component is running, which updates the state.
    , eval: H.mkEval $ H.defaultEval { handleAction = handleAction }
    }
</code></pre>
<p>We'll talk more about the <code>eval</code> function in future chapters. For the time being you can think of the <code>eval</code> function as defining how the component responds to events; for now, the only kind of events we care about are actions, and so the only function we'll use is <code>handleAction</code>.</p>
<p>Our component is now complete, but we're missing one last type definition: our component type.</p>
<h3><a class="header" href="#the-hcomponent-type" id="the-hcomponent-type">The <code>H.Component</code> Type</a></h3>
<p>The <code>mkComponent</code> function produces a component from a <code>ComponentSpec</code>, which is a record of the functions that Halogen needs to run a component. We'll get into more detail about this type in a subsequent chapter.</p>
<pre><code class="language-purs">mkComponent :: H.ComponentSpec ... -&gt; H.Component query input output m
</code></pre>
<p>The resulting component has the type <code>H.Component</code>, which itself takes four type parameters that describe the public interface of the component. Our component doesn't communicate with parent components or child components, so it doesn't use any of these type variables. Still, we'll briefly step through them now so you know what's coming in subsequent chapters.</p>
<ol>
<li>The first parameter <code>query</code> represents a way that parent components can communicate with this component. We will talk about it more when we talk about parent and child components.</li>
<li>The second parameter <code>input</code> represents the input our component accepts. In our case, the component doesn't accept any input, so we'll leave this variable open.</li>
<li>The third parameter <code>output</code> represents a way that this component can communicate with its parent component. We'll talk about it more when we talk about parent and child components.</li>
<li>The final parameter, <code>m</code>, represents the monad that can be used to run effects in the component. Our component doesn't run any effects, so we'll leave this variable open.</li>
</ol>
<p>Our counter component can therefore be specified by leaving all of the <code>H.Component</code> type variables open.</p>
<h2><a class="header" href="#the-final-product" id="the-final-product">The Final Product</a></h2>
<p>That was a lot to take in! We've finally got our counter component fully specified with types. If you can comfortably build components like this one, you're most of the way to a thorough understanding of building Halogen components in general. The rest of this guide will build on top of your understanding of state, actions, and rendering HTML.</p>
<p>We've added a <code>main</code> function that runs our Halogen application so that you can try this example out by pasting it into <a href="https://try.purescript.org">Try PureScript</a>. We'll cover how to run Halogen applications in a later chapter -- for now you can ignore the <code>main</code> function and focus on the component we've defined.</p>
<pre><code class="language-purs">module Main where

import Prelude

import Effect (Effect)
import Halogen as H
import Halogen.Aff as HA
import Halogen.HTML as HH
import Halogen.HTML.Events as HE
import Halogen.VDom.Driver (runUI)

main :: Effect Unit
main = HA.runHalogenAff do
  body &lt;- HA.awaitBody
  runUI component unit body

type State = Int

data Action = Increment | Decrement

component :: forall query input output m. H.Component query input output m
component =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval H.defaultEval { handleAction = handleAction }
    }

initialState :: forall input. input -&gt; State
initialState _ = 0

render :: forall m. State -&gt; H.ComponentHTML Action () m
render state =
  HH.div_
    [ HH.button [ HE.onClick \_ -&gt; Decrement ] [ HH.text &quot;-&quot; ]
    , HH.text (show state)
    , HH.button [ HE.onClick \_ -&gt; Increment ] [ HH.text &quot;+&quot; ]
    ]

handleAction :: forall output m. Action -&gt; H.HalogenM State Action () output m Unit
handleAction = case _ of
  Decrement -&gt;
    H.modify_ \state -&gt; state - 1

  Increment -&gt;
    H.modify_ \state -&gt; state + 1
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../guide/01-Rendering-Halogen-HTML.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../guide/03-Performing-Effects.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../guide/01-Rendering-Halogen-HTML.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../guide/03-Performing-Effects.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
