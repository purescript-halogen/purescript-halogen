<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Performing Effects - Halogen Guide</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Halogen</a></li><li class="chapter-item expanded "><a href="../guide/index.html"><strong aria-hidden="true">2.</strong> Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../guide/01-Rendering-Halogen-HTML.html"><strong aria-hidden="true">2.1.</strong> Rendering Halogen HTML</a></li><li class="chapter-item expanded "><a href="../guide/02-Introducing-Components.html"><strong aria-hidden="true">2.2.</strong> Introducing Components</a></li><li class="chapter-item expanded "><a href="../guide/03-Performing-Effects.html" class="active"><strong aria-hidden="true">2.3.</strong> Performing Effects</a></li><li class="chapter-item expanded "><a href="../guide/04-Lifecycles-Subscriptions.html"><strong aria-hidden="true">2.4.</strong> Lifecycles &amp; Subscriptions</a></li><li class="chapter-item expanded "><a href="../guide/05-Parent-Child-Components.html"><strong aria-hidden="true">2.5.</strong> Parent &amp; Child Components</a></li><li class="chapter-item expanded "><a href="../guide/06-Running-Application.html"><strong aria-hidden="true">2.6.</strong> Running Application</a></li><li class="chapter-item expanded "><a href="../guide/07-Next-Steps.html"><strong aria-hidden="true">2.7.</strong> Next Steps</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts-reference/index.html"><strong aria-hidden="true">3.</strong> Concepts Reference</a></li><li class="chapter-item expanded "><a href="../changelog/index.html"><strong aria-hidden="true">4.</strong> Major Version Changelog</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../changelog/v5.html"><strong aria-hidden="true">4.1.</strong> Changes in v5</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Halogen Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#performing-effects" id="performing-effects">Performing Effects</a></h1>
<p>We've covered a lot of ground so far. You know how to write Halogen HTML. You can define components that respond to user interactions and model each part of the component in types. With this foundation we can move on to another vital tool when writing applications: performing effects.</p>
<p>In this chapter we'll explore how to perform effects in your component through two examples: generating random numbers and making HTTP requests. Once you know how to perform effects you are well on your way to mastering Halogen fundamentals.</p>
<p>Before we start, it's important to know that you can only perform effects during evaluation, which means functions like <code>handleAction</code> which use the type <code>HalogenM</code>. You can't perform effects when you produce your initial state or during rendering. Since you can only perform effects when you're within <code>HalogenM</code>, let's briefly learn more about it before diving in to the examples.</p>
<h2><a class="header" href="#the-halogenm-type" id="the-halogenm-type">The <code>HalogenM</code> Type</a></h2>
<p>If you recall from last chapter, the <code>handleAction</code> function returns a type called <code>HalogenM</code>. Here's the <code>handleAction</code> we wrote:</p>
<pre><code class="language-purs">handleAction :: forall output m. Action -&gt; HalogenM State Action () output m Unit
</code></pre>
<p><code>HalogenM</code> is a crucial part of Halogen, often called the &quot;eval&quot; monad. This monad enables Halogen features like state, forking threads, starting subscriptions, and more. But it's quite limited, concerning itself only with Halogen-specific features. In fact, Halogen components have no built-in mechanisms for effects!</p>
<p>Instead, Halogen lets you choose what monad you would like to use with <code>HalogenM</code> in your component. You gain access to all the capabilities of <code>HalogenM</code> <em>and also</em> whatever capabilities your chosen monad supports. This is represented with the type parameter <code>m</code>, which stands for &quot;monad&quot;.</p>
<p>A component that only uses Halogen-specific features can leave this type parameter open. Our counter, for example, only updated state. But a component that performs effects can use the <code>Effect</code> or <code>Aff</code> monads, or you can supply a custom monad of your own.</p>
<p>This <code>handleAction</code> is able to use functions from <code>HalogenM</code> like <code>modify_</code> and can also use effectful functions from <code>Effect</code>:</p>
<pre><code class="language-purs">handleAction :: forall o. Action -&gt; HalogenM State Action () o Effect Unit
</code></pre>
<p>This one can use functions from <code>HalogenM</code> and also effectful functions from <code>Aff</code>:</p>
<pre><code class="language-purs">handleAction :: forall output. Action -&gt; HalogenM State Action () output Aff Unit
</code></pre>
<p>It is more common in Halogen to use constraints on the type parameter <code>m</code> to describe what the monad can do rather than choose a specific monad, which allows you to mix several monads together as your application grows. For example, most Halogen apps would use functions from <code>Aff</code> via this type signature:</p>
<pre><code class="language-purs">handleAction :: forall output m. MonadAff m =&gt; Action -&gt; HalogenM State Action () output m Unit
</code></pre>
<p>This lets you do everything the hardcoded <code>Aff</code> type did, but it also lets you mix in other constraints too.</p>
<p>One last thing: when you choose a monad for your component it will show up in your <code>HalogenM</code> type, your <code>Component</code> type, and, if you are using child components, in your <code>ComponentHTML</code> type:</p>
<pre><code class="language-purs">component :: forall query input output m. MonadAff m =&gt; H.Component HH.HTML query input output m

handleAction :: forall output m. MonadAff m =&gt; Action -&gt; HalogenM State Action () output m Unit

-- We aren't using child components, so we don't have to use the constraint here, but
-- we'll learn about when it's required in the parent &amp; child components chapter.
render :: forall m. State -&gt; H.ComponentHTML Action () m
</code></pre>
<h2><a class="header" href="#an-effect-example-random-numbers" id="an-effect-example-random-numbers">An <code>Effect</code> Example: Random Numbers</a></h2>
<p>Let's create a new, simple component that generates a new random number each time you click a button. As you read through the example, notice how it uses the same types and functions that we used to write our counter. Over time you'll become used to scanning the state, action, and other types of a Halogen component to get a gist of what it does, and familiar with standard functions like <code>initialState</code>, <code>render</code>, and <code>handleAction</code>.</p>
<blockquote>
<p>You can paste this example into <a href="https://try.purescript.org">Try Purescript</a> to explore it interactively. You can also see and run the <a href="https://github.com/purescript-halogen/purescript-halogen/tree/master/examples/effects-effect-random">full example code</a> from the <code>examples</code> directory in this repository.</p>
</blockquote>
<p>Notice that we don't perform any effects in our <code>initialState</code> or <code>render</code> functions -- for example, we initialize our state to <code>Nothing</code> rather than generate a random number for our initial state -- but we're free to perform effects in our <code>handleAction</code> function (which uses the <code>HalogenM</code> type).</p>
<pre><code class="language-purs">module Main where

import Prelude

import Data.Maybe (Maybe(..), maybe)
import Effect (Effect)
import Effect.Class (class MonadEffect)
import Effect.Random (random)
import Halogen as H
import Halogen.Aff (awaitBody, runHalogenAff)
import Halogen.HTML as HH
import Halogen.HTML.Events as HE
import Halogen.VDom.Driver (runUI)

main :: Effect Unit
main = runHalogenAff do
  body &lt;- awaitBody
  runUI component unit body

type State = Maybe Number

data Action = Regenerate

component :: forall query input output m. MonadEffect m =&gt; H.Component HH.HTML query input output m
component =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval $ H.defaultEval { handleAction = handleAction }
    }

initialState :: forall input. input -&gt; State
initialState _ = Nothing

render :: forall m. State -&gt; H.ComponentHTML Action () m
render state = do
  let value = maybe &quot;No number generated yet&quot; show state
  HH.div_
    [ HH.h1_
        [ HH.text &quot;Random number&quot; ]
    , HH.p_
        [ HH.text (&quot;Current value: &quot; &lt;&gt; value) ]
    , HH.button
        [ HE.onClick \_ -&gt; Just Regenerate ]
        [ HH.text &quot;Generate new number&quot; ]
    ]

handleAction :: forall output m. MonadEffect m =&gt; Action -&gt; H.HalogenM State Action () output m Unit
handleAction = case _ of
  Regenerate -&gt; do
    newNumber &lt;- H.liftEffect random
    H.modify_ \_ -&gt; Just newNumber
</code></pre>
<p>As you can see, a component that performs effects is not much different from a component that doesn't! We've only done two things:</p>
<ol>
<li>We added a <code>MonadEffect</code> constraint to the <code>m</code> type parameter for our component <em>and</em> for our <code>handleAction</code> function. We don't need the constraint for our render function because we don't have any child components.</li>
<li>We actually <em>used</em> an effect for the first time: the <code>random</code> function, which comes from <code>Effect.Random</code>.</li>
</ol>
<p>Let's break down using this effect a little more.</p>
<pre><code class="language-purs">--                          [1]
handleAction :: forall output m. MonadEffect m =&gt; Action -&gt; H.HalogenM State Action () output m Unit
handleAction = case _ of
  Regenerate -&gt; do
    newNumber &lt;- H.liftEffect random -- [2]
    H.modify_ \_ -&gt; Just newNumber   -- [3]
</code></pre>
<ol>
<li>We have constrained our <code>m</code> type parameter to say we support any monad, so long as that monad supports <code>MonadEffect</code>. It's another way to say &quot;We need to be able to use <code>Effect</code> functions in our evaluation code.&quot;</li>
<li>The <code>random</code> function has the type <code>Effect Number</code>. But we can't use it directly: our component doesn't support <code>Effect</code> but rather <em>any</em> monad <code>m</code> so long as that monad can run effects from <code>Effect</code>. It's a subtle difference, but in the end we require the <code>random</code> function to have the type <code>MonadEffect m =&gt; m Number</code> instead of being <code>Effect</code> directly. Fortunately, we can convert any <code>Effect</code> type to <code>MonadEffect m =&gt; m</code> using the <code>liftEffect</code> function. This is a common pattern in Halogen, so keep <code>liftEffect</code> in mind if you're using <code>MonadEffect</code>.</li>
<li>The <code>modify_</code> function lets you update state, and it comes directly from <code>HalogenM</code> with the other state update functions. Here we use it to write the new random number to our state.</li>
</ol>
<p>This is a nice example of how you can freely interleave effects from <code>Effect</code> with Halogen-specific functions like <code>modify_</code>. Let's do it again, this time using the <code>Aff</code> monad for asynchronous effects.</p>
<h2><a class="header" href="#an-aff-example-http-requests" id="an-aff-example-http-requests">An <code>Aff</code> Example: HTTP Requests</a></h2>
<p>It's common to fetch information from elsewhere on the Internet. For example, let's say we'd like to work with GitHub's API to fetch users. We'll use the <a href="https://pursuit.purescript.org/packages/purescript-affjax"><code>affjax</code></a> package to make our requests, which itself relies on the <code>Aff</code> monad for asynchronous effects.</p>
<p>This example is even more interesting, though: we'll also use the <code>preventDefault</code> function to prevent form submission from refreshing the page, which runs in <code>Effect</code>. That means our example shows how you can interleave different effects together (<code>Effect</code> and <code>Aff</code>) along with Halogen functions (<code>HalogenM</code>).</p>
<blockquote>
<p>As with the Random example, you can paste this example into <a href="https://try.purescript.org">Try Purescript</a> to explore it interactively. You can also see and run the <a href="https://github.com/purescript-halogen/purescript-halogen/tree/master/examples/effects-aff-ajax">full example code</a> from the <code>examples</code> directory in this repository.</p>
</blockquote>
<p>This component definition should start to look familiar. We define our <code>State</code> and <code>Action</code> types and implement our <code>initialState</code>, <code>render</code>, and <code>handleAction</code> functions. We bring them together into our component spec and turn them into a valid component <code>H.mkComponent</code>.</p>
<p>Once again, notice that our effects are concentrated in the <code>handleAction</code> function and no effects are performed when making the initial state or rendering Halogen HTML.</p>
<pre><code class="language-purs">module Main where

import Prelude

import Affjax as AX
import Affjax.ResponseFormat as AXRF
import Data.Either (hush)
import Data.Maybe (Maybe(..))
import Effect (Effect)
import Effect.Aff.Class (class MonadAff)
import Halogen as H
import Halogen.Aff (awaitBody, runHalogenAff)
import Halogen.HTML as HH
import Halogen.HTML.Events as HE
import Halogen.HTML.Properties as HP
import Halogen.VDom.Driver (runUI)
import Web.Event.Event (Event)
import Web.Event.Event as Event

main :: Effect Unit
main = runHalogenAff do
  body &lt;- awaitBody
  runUI component unit body

type State =
  { loading :: Boolean
  , username :: String
  , result :: Maybe String
  }

data Action
  = SetUsername String
  | MakeRequest Event

component :: forall query input output m. MonadAff m =&gt; H.Component HH.HTML query input output m
component =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval $ H.defaultEval { handleAction = handleAction }
    }

initialState :: forall i. i -&gt; State
initialState _ = { loading: false, username: &quot;&quot;, result: Nothing }

render :: forall m. State -&gt; H.ComponentHTML Action () m
render st =
  HH.form
    [ HE.onSubmit \ev -&gt; Just (MakeRequest ev) ]
    [ HH.h1_ [ HH.text &quot;Look up GitHub user&quot; ]
    , HH.label_
        [ HH.div_ [ HH.text &quot;Enter username:&quot; ]
        , HH.input
            [ HP.value st.username
            , HE.onValueInput \str -&gt; Just (SetUsername str)
            ]
        ]
    , HH.button
        [ HP.disabled st.loading
        , HP.type_ HP.ButtonSubmit
        ]
        [ HH.text &quot;Fetch info&quot; ]
    , HH.p_
        [ HH.text (if st.loading then &quot;Working...&quot; else &quot;&quot;) ]
    , HH.div_
        case st.result of
          Nothing -&gt; []
          Just res -&gt;
            [ HH.h2_
                [ HH.text &quot;Response:&quot; ]
            , HH.pre_
                [ HH.code_ [ HH.text res ] ]
            ]
    ]

handleAction :: forall output m. MonadAff m =&gt; Action -&gt; H.HalogenM State Action () output m Unit
handleAction = case _ of
  SetUsername username -&gt; do
    H.modify_ _ { username = username, result = Nothing }

  MakeRequest event -&gt; do
    H.liftEffect $ Event.preventDefault event
    username &lt;- H.gets _.username
    H.modify_ _ { loading = true }
    response &lt;- H.liftAff $ AX.get AXRF.string (&quot;https://api.github.com/users/&quot; &lt;&gt; username)
    H.modify_ _ { loading = false, result = map _.body (hush response) }
</code></pre>
<p>This example is especially interesting because:</p>
<ol>
<li>It mixes together functions from multiple monads (<code>preventDefault</code> is <code>Effect</code>, <code>AX.get</code> is <code>Aff</code>, and <code>gets</code> and <code>modify_</code> are <code>HalogenM</code>). We're able to use <code>liftEffect</code> and <code>liftAff</code> along with our constraints to make sure everything plays well together.</li>
<li>We only have one constraint, <code>MonadAff</code>. That's because anything that can be run in <code>Effect</code> can also be run in <code>Aff</code>, so <code>MonadAff</code> implies <code>MonadEffect</code>.</li>
<li>We're making multiple state updates in one evaluation.</li>
</ol>
<p>That last point is especially important: when you modify state your component renders. That means that during this evaluation we:</p>
<ol>
<li>Set <code>loading</code> to <code>true</code>, which causes the component to re-render and display &quot;Working...&quot;</li>
<li>Set <code>loading</code> to <code>false</code> and update the result, which causes the component to re-render and display the result (if there was one).</li>
</ol>
<p>It's worth noting that because we're using <code>MonadAff</code> our request will not block the component from doing other work, and we don't have to deal with callbacks to get this async superpower. The computation we've written in <code>MakeRequest</code> simply suspends until we get the response and then proceeds to update the state the second time.</p>
<p>It's a smart idea to only modify state when necessary and to batch updates together if possible (like how we call <code>modify_</code> once to update both the <code>loading</code> and <code>result</code> fields). That helps make sure you're only re-rendering when needed.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../guide/02-Introducing-Components.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../guide/04-Lifecycles-Subscriptions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../guide/02-Introducing-Components.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../guide/04-Lifecycles-Subscriptions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
