module Halogen.Driver
  ( Driver
  , runUI
  , runDriver
  ) where

import Prelude
import Control.Coroutine.Stalling as SCR
import Control.Bind ((=<<))
import Control.Coroutine (await)
import Control.Coroutine.Stalling (($$?))
import Control.Monad.Aff (Aff, forkAff, forkAll)
import Control.Monad.Aff.AVar (AVAR, AVar, makeVar, makeVar', putVar, takeVar, modifyVar)
import Control.Monad.Eff.Class (liftEff)
import Control.Monad.Free (runFreeM)
import Control.Monad.Rec.Class (forever, tailRecM)
import Control.Monad.State (runState)
import Control.Monad.Trans (lift)
import Control.Plus (empty)
import DOM.HTML.Types (HTMLElement, htmlElementToNode)
import DOM.Node.Node (appendChild)
import Data.Either (Either(..))
import Data.Foldable (class Foldable, foldr)
import Data.List (List(Nil), (:))
import Data.Maybe (Maybe(..), maybe, isJust, isNothing)
import Data.Tuple (Tuple(..))
import Halogen.Component (Component, ComponentDSL, RawComponent, initializeComponent, renderComponent, queryComponent)
import Halogen.Component.Hook (Hook(..), Finalized, runFinalized)
import Halogen.Component.Tree (Tree)
import Halogen.Effects (HalogenEffects)
import Halogen.HTML.Core (HTML)
import Halogen.HTML.Renderer.VirtualDOM (renderTree)
import Halogen.Internal.VirtualDOM (VTree, createElement, diff, patch)
import Halogen.Query (HalogenF, HalogenFP(..))
import Halogen.Query.EventSource (runEventSource)
import Halogen.Query.HalogenF (RenderPending(..))
import Halogen.Query.StateF (StateF(..), stateN)

-- | Type alias for driver functions generated by `runUI` - a driver takes an
-- | input of the query algebra (`f`) and returns an `Aff` that returns when
-- | query has been fulfilled.
type Driver f eff = f ~> Aff (HalogenEffects eff)

-- | Type alias used internally to track the driver's persistent state.
type DriverState s bs =
  {
    backendState :: bs
  , state :: s
  , renderPending :: Boolean
  , renderPaused :: Boolean
  }

type DriverInterface f eff bs = {
  driver :: Driver f eff,
  initialState :: bs,
  modifyState :: (bs -> bs) -> Aff (avar::AVAR| eff) Unit
}

type VirtualDOMState = { vtree :: VTree, node :: HTMLElement }

runUI :: forall s f eff.
 Component s f (Aff (HalogenEffects eff))
 -> s
 -> HTMLElement
 -> Aff (HalogenEffects eff) (Driver f eff)
runUI c s element = _.driver <$> runDriver renderInitial renderUpdate c s
  where
  renderInitial :: forall p. Driver f eff -> Tree HTML f p -> Aff (HalogenEffects eff) VirtualDOMState
  renderInitial dr tree = do
    let vtree = renderTree dr tree
    let node = createElement vtree
    liftEff $ appendChild (htmlElementToNode node) (htmlElementToNode element)
    pure $ { vtree, node }
  renderUpdate :: forall p. Driver f eff -> Tree HTML f p -> VirtualDOMState -> Aff (HalogenEffects eff) VirtualDOMState
  renderUpdate dr tree ds = do
    let vtree = renderTree dr tree
    node <- liftEff $ patch (diff ds.vtree vtree) ds.node
    pure $ { vtree, node }


-- | This function is the main entry point for a Halogen based UI, taking a root
-- | component, initial state, and HTML element to attach the rendered component
-- | to.
-- |
-- | The returned "driver" function can be used to send actions and requests
-- | into the component hierarchy, allowing the outside world to communicate
-- | with the UI.
runDriver :: forall h s bs f eff.
  (forall p. Driver f eff -> Tree h f p -> Aff (HalogenEffects eff) bs)
  -> (forall p. Driver f eff -> Tree h f p -> bs -> Aff (HalogenEffects eff) bs)
  -> RawComponent h s f (Aff (HalogenEffects eff))
  -> s
  -> Aff (HalogenEffects eff) (DriverInterface f eff bs)
runDriver ir upd c s = do
  ref <- makeVar
  let rc = renderComponent c s
      dr = driver ref :: Driver f eff
  initialState <- ir dr rc.tree
  putVar ref
    { backendState : initialState
    , state: rc.state
    , renderPending: false
    , renderPaused: true
    }
  forkAll $ onInitializers dr rc.hooks
  forkAff $ maybe (pure unit) dr (initializeComponent c)
  modifyVar _ { renderPaused = false } ref
  flushRender ref
  pure { driver: dr, initialState, modifyState: \f -> modifyVar (\a -> a { backendState = f a.backendState }) ref }

  where
  driver :: AVar (DriverState s bs) -> Driver f eff
  driver ref q = do
    rpRef <- makeVar' Nothing
    x <- runFreeM (eval ref rpRef) (queryComponent c q)
    rp <- takeVar rpRef
    when (isJust rp) $ render ref
    pure x

  eval
    :: AVar (DriverState s bs)
    -> AVar (Maybe RenderPending)
    -> HalogenF s f (Aff (HalogenEffects eff))
    ~> Aff (HalogenEffects eff)
  eval ref rpRef h =
    case h of
      StateHF i -> do
        ds <- takeVar ref
        case i of
          Get k -> do
            putVar ref ds
            pure (k ds.state)
          Modify f next -> do
            rp <- takeVar rpRef
            putVar ref $ ds { state = f ds.state }
            putVar rpRef $ Just Pending
            pure next
      SubscribeHF es next -> do
        let producer = runEventSource es
            consumer = forever (lift <<< driver ref =<< await)
        forkAff $ SCR.runStallingProcess (producer $$? consumer)
        pure next
      RenderHF p next -> do
        modifyVar (const p) rpRef
        when (isNothing p) $ render ref
        pure next
      RenderPendingHF k -> do
        rp <- takeVar rpRef
        putVar rpRef rp
        pure $ k rp
      QueryHF q -> do
        rp <- takeVar rpRef
        when (isJust rp) $ render ref
        putVar rpRef Nothing
        q
      HaltHF -> empty

  driver'
    :: forall s' f'
     . (f' ~> ComponentDSL s' f' (Aff (HalogenEffects eff)))
    -> s'
    -> f' Unit
    -> Aff (HalogenEffects eff) Unit
  driver' e s i = do
    ref <- makeVar' s
    flip runFreeM (e i) \h ->
      case h of
        StateHF i -> do
          ds <- takeVar ref
          case runState (stateN i) ds of
            Tuple i' s' -> do
              putVar ref s'
              pure i'
        SubscribeHF _ next -> pure next
        RenderHF p next -> pure next
        RenderPendingHF k -> pure $ k Nothing
        QueryHF q -> q
        HaltHF -> empty

  render :: AVar (DriverState s bs) -> Aff (HalogenEffects eff) Unit
  render ref = do
    ds <- takeVar ref
    if ds.renderPaused
      then putVar ref $ ds { renderPending = true }
      else do
        let rc = renderComponent c ds.state
        bs' <- upd (driver ref) rc.tree ds.backendState
        putVar ref
          { backendState: bs'
          , state: rc.state
          , renderPending: false
          , renderPaused: true
          }
        forkAll $ onFinalizers (runFinalized driver') rc.hooks
        forkAll $ onInitializers (driver ref) rc.hooks
        modifyVar _ { renderPaused = false } ref
        flushRender ref

  flushRender :: AVar (DriverState s bs) -> Aff (HalogenEffects eff) Unit
  flushRender = tailRecM \ref -> do
    ds <- takeVar ref
    putVar ref ds
    if not ds.renderPending
      then pure (Right unit)
      else do
        render ref
        pure (Left ref)

onInitializers
  :: forall m f g r
   . Foldable m
  => (f Unit -> r)
  -> m (Hook f g)
  -> List r
onInitializers f = foldr go Nil
  where
  go (PostRender a) as = f a : as
  go _              as = as

onFinalizers
  :: forall m f g r
   . Foldable m
  => (Finalized g -> r)
  -> m (Hook f g)
  -> List r
onFinalizers f = foldr go Nil
  where
  go (Finalized a)  as = f a : as
  go _              as = as
