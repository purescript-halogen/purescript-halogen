module Halogen.Driver
  ( Driver()
  , runUI
  ) where

import Prelude

import Control.Bind ((=<<))
import Control.Coroutine (await)
import Control.Coroutine.Stalling (($$?))
import Control.Coroutine.Stalling as SCR
import Control.Monad.Aff (Aff(), forkAff)
import Control.Monad.Aff.AVar (AVar(), makeVar, makeVar', putVar, takeVar)
import Control.Monad.Eff.Class (liftEff)
import Control.Monad.Free (runFreeM)
import Control.Monad.Rec.Class (forever)
import Control.Monad.State (runState)
import Control.Monad.Trans (lift)
import Control.Plus (Plus, empty)

import Data.Foldable (Foldable, sequence_, traverse_, foldr)
import Data.List (List(Nil), (:))
import Data.Maybe (Maybe(..), maybe)
import Data.NaturalTransformation (Natural())
import Data.Tuple (Tuple(..))

import DOM.HTML.Types (HTMLElement())

import Halogen.Component (Component(), Eval(), renderComponent, queryComponent, initializeComponent)
import Halogen.Component.Hook (Hook(..), Finalized(), runFinalized)
import Halogen.Effects (HalogenEffects())
import Halogen.HTML.Core (HTML())
import Halogen.HTML.Renderer.VirtualDOM (renderHTML)
import Halogen.Internal.VirtualDOM (VTree(), createElement, diff, patch)
import Halogen.Query (HalogenF(), HalogenFP(..))
import Halogen.Query.StateF (stateN)
import Halogen.Query.EventSource (runEventSource)

-- | Type alias for driver functions generated by `runUI` - a driver takes an
-- | input of the query algebra (`f`) and returns an `Aff` that returns when
-- | query has been fulfilled.
type Driver f eff = Natural f (Aff (HalogenEffects eff))

-- | Type alias used internally to track the driver's persistent state.
type DriverState s =
  { node :: HTMLElement
  , vtree :: VTree
  , state :: s
  , renderPending :: Boolean
  }

-- | This function is the main entry point for a Halogen based UI.
-- |
-- | The returned value contains the HTML element for the component tree that
-- | then needs attaching to the DOM, and a driver function that can be used to
-- | send actions and requests into the component hierarchy.
-- |
-- | The returned driver function allows the "outside world" to communicate
-- | with the UI - a common use case it to use the driver to changes to the
-- | application state in combination with a routing library.
runUI
  :: forall s f eff
   . Component s f (Aff (HalogenEffects eff))
  -> s
  -> Aff (HalogenEffects eff) { node :: HTMLElement, driver :: Driver f eff }
runUI c s = do
  ref <- makeVar
  let rc = renderComponent c s
      vtree = renderHTML (driver ref) rc.html
      node = createElement vtree
  putVar ref { node: node, vtree: vtree, state: rc.state, renderPending: false }
  sequence_ $ onInitializers (forkAff <<< driver ref) rc.hooks
  maybe (pure unit) (driver ref) (initializeComponent c)
  pure { node: node, driver: driver ref }

  where

  driver :: AVar (DriverState s) -> Driver f eff
  driver ref q = do
    x <- runFreeM (eval ref) (queryComponent c q)
    render ref
    pure x

  eval
    :: AVar (DriverState s)
    -> Natural (HalogenF s f (Aff (HalogenEffects eff))) (Aff (HalogenEffects eff))
  eval ref h =
    case h of
      StateHF i -> do
        ds <- takeVar ref
        case runState (stateN i) ds.state of
          Tuple i' s' -> do
            putVar ref { node: ds.node, vtree: ds.vtree, state: s', renderPending: true }
            pure i'

      SubscribeHF es next -> do
        let producer = runEventSource es
            consumer = forever (lift <<< driver ref =<< await)
        forkAff $ SCR.runStallingProcess (producer $$? consumer)
        pure next
      QueryHF q -> do
        render ref
        q
      HaltHF -> empty

  driver'
    :: forall s' f'
     . Eval f' s' f' (Aff (HalogenEffects eff))
    -> s'
    -> f' Unit
    -> Aff (HalogenEffects eff) Unit
  driver' e s i = do
    ref <- makeVar' s
    flip runFreeM (e i) \h ->
      case h of
        StateHF i -> do
          ds <- takeVar ref
          case runState (stateN i) ds of
            Tuple i' s' -> do
              putVar ref s'
              pure i'
        SubscribeHF _ next -> pure next
        QueryHF q -> q
        HaltHF -> empty

  render :: AVar (DriverState s) -> Aff (HalogenEffects eff) Unit
  render ref = do
    ds <- takeVar ref
    if not ds.renderPending
      then putVar ref ds
      else do
        let rc = renderComponent c ds.state
            vtree' = renderHTML (driver ref) (rc.html)
        node' <- liftEff $ patch (diff ds.vtree vtree') ds.node
        putVar ref { node: node', vtree: vtree', state: rc.state, renderPending: false }
        sequence_ $ onFinalizers (forkAff <<< runFinalized driver') rc.hooks
        sequence_ $ onInitializers (forkAff <<< driver ref) rc.hooks

onInitializers :: forall m f g r. (Foldable m) => (f Unit -> r) -> m (Hook f g) -> List r
onInitializers f = foldr go Nil
  where
  go (PostRender a) as = f a : as
  go _              as = as

onFinalizers :: forall m f g r. (Foldable m) => (Finalized g -> r) -> m (Hook f g) -> List r
onFinalizers f = foldr go Nil
  where
  go (Finalized a)  as = f a : as
  go _              as = as
