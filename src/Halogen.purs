module Halogen
  ( Driver()
  , runUI
  , actionF
  , actionCF
  , actionFC
  , requestF
  , requestCF
  , requestFC
  , module Halogen.Component
  , module Halogen.Effects
  ) where

import Prelude

import Control.Monad.Aff (Aff())
import Control.Monad.Aff.AVar (AVar(), makeVar, putVar, takeVar)
import Control.Monad.Eff.Class (liftEff)
import Control.Monad.Free (Free(), FreeC(), runFreeM, liftFI, liftFCI)
import Control.Monad.State (runState)

import Data.Coyoneda (Natural(), Coyoneda(), liftCoyoneda)
import Data.DOM.Simple.Types (HTMLElement())
import Data.Functor.Coproduct (Coproduct(), coproduct)
import Data.Inject (Inject)
import Data.Tuple (Tuple(..))
import Data.Void (Void())

import Halogen.Component (Component(), renderComponent, queryComponent)
import Halogen.Effects (HalogenEffects())
import Halogen.HTML.Renderer.VirtualDOM (RenderState(), emptyRenderState, renderHTML)
import Halogen.Internal.VirtualDOM (VTree(), createElement, diff, patch)
import Halogen.Query.StateF (StateF(), stateN)

-- | Type alias for driver functions generated by runUI - a driver takes an
-- | input of the query algebra (`f`) and returns an `Aff` that returns when
-- | query has been fulfilled.
type Driver f eff = Natural f (Aff (HalogenEffects eff))

-- | Type alias used internally to track the driver's persistent state.
type DriverState s =
  { node :: HTMLElement
  , vtree :: VTree
  , state :: s
  , memo :: RenderState
  }

-- | Runs the top level UI component for a Halogen app, returning a generated
-- | HTML element that can be attached to the DOM and a driver function that
-- | can be used to send actions and requests into the component (see the
-- | [`actionF`](#actionf), [`requestF`](#requestF), and related variations for
-- | more details on querying the driver).
runUI :: forall eff s f. Component s f (Aff (HalogenEffects eff)) Void
      -> s
      -> Aff (HalogenEffects eff) { node :: HTMLElement, driver :: Driver f eff }
runUI c s = case renderComponent c s of
    Tuple html s' -> do
      ref <- makeVar
      case renderHTML (driver ref) html emptyRenderState of
        Tuple vtree memo -> do
          let node = createElement vtree
          putVar ref { node: node, vtree: vtree, state: s', memo: memo }
          pure { node: node, driver: driver ref }

  where

  driver :: AVar (DriverState s) -> Driver f eff
  driver ref q = runFreeM (eval ref) (queryComponent c q)

  eval :: AVar (DriverState s)
       -> Natural (Coproduct (StateF s) (Aff (HalogenEffects eff)))
                  (Aff (HalogenEffects eff))
  eval ref = coproduct runStateStep id
    where
    runStateStep :: Natural (StateF s) (Aff (HalogenEffects eff))
    runStateStep i = do
      { node: node, vtree: vtree, state: s, memo: memo } <- takeVar ref
      case runState (stateN i) s of
        Tuple i' s' ->
          case renderComponent c s' of
            Tuple html s'' -> do
              case renderHTML (driver ref) html memo of
                Tuple vtree' memo' -> do
                  node' <- liftEff $ patch (diff vtree vtree') node
                  putVar ref { node: node', vtree: vtree', state: s'', memo: memo' }
                  pure i'

-- | Takes a data constructor of `f` and creates an "action", lifting it into
-- | the query algebra `Free g Unit`. An "action" only causes effects and has
-- | no result value.
-- |
-- | For example:
-- |
-- | ```purescript
-- | data Input a = Tick a
-- |
-- | instance functorInput :: Functor Input where
-- |   map f (Tick a) = Tick (f a)
-- |
-- | sendTick :: forall eff. Driver (Free Input) eff -> Aff (HalogenEffects eff) Unit
-- | sendTick driver = driver (actionF Tick)
-- | ```
-- |
-- | Commonly `g` and `f` may be the same `Functor`, but when using `Coproduct`
-- | to combine multiple algebras this function performs the work of generating
-- | the correct value for the composite algebra.
actionF :: forall f g. (Functor f, Functor g, Inject f g) => (Unit -> f Unit) -> Free g Unit
actionF f = liftFI (f unit)

-- | A version of `actionF` that lifts values into `Free g Unit` via `Coyoneda`.
-- | This is useful in cases where `g` is a `Coproduct` containing `Coyoneda f`.
actionCF :: forall f g. (Functor g, Inject (Coyoneda f) g) => (Unit -> f Unit) -> Free g Unit
actionCF f = actionF (liftCoyoneda <<< f)

-- | A version of `actionF` that lifts values into `FreeC g Unit`.
actionFC :: forall f g. (Inject f g) => (Unit -> f Unit) -> FreeC g Unit
actionFC f = liftFCI (f unit)

-- | Takes a data constructor of `f` and creates a "request", lifting it into
-- | the query algebra `Free g a`. A "request" can cause effects as well as
-- | fetching some information from a component.
-- |
-- | For example:
-- |
-- | ```purescript
-- | data Input a = GetTickCount (Int -> a)
-- |
-- | instance functorInput :: Functor Input where
-- |   map f (GetTickCount k) = GetTickCount (f <<< k)
-- |
-- | getTickCount :: forall eff. Driver (Free Input) eff -> Aff (HalogenEffects eff) Int
-- | getTickCount driver = driver (requestF GetTickCount)
-- | ```
-- |
-- | As with `actionF`, `g` and `f` may be the same `Functor`, but when using
-- | `Coproduct` to combine multiple algebras this function performs the work of
-- | generating the correct value for the composite algebra.
requestF :: forall f g a. (Functor f, Functor g, Inject f g) => (forall i. (a -> i) -> f i) -> Free g a
requestF f = liftFI (f id)

-- | A version of `requestF` that lifts values into `Free g a` via `Coyoneda`.
-- | This is useful in cases where `g` is a `Coproduct` containing `Coyoneda f`.
requestCF :: forall f g a. (Functor g, Inject (Coyoneda f) g) => (forall i. (a -> i) -> f i) -> Free g a
requestCF f = requestF (liftCoyoneda <<< f)

-- | A version of `requestF` that lifts values into `FreeC g a`.
requestFC :: forall f g a. (Inject f g) => (forall i. (a -> i) -> f i) -> FreeC g a
requestFC f = liftFCI (f id)
